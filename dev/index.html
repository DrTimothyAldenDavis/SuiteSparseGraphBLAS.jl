<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SuiteSparseGraphBLAS.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SuiteSparseGraphBLAS.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Roadmap"><span>Roadmap</span></a></li><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li class="toplevel"><a class="tocitem" href="#GraphBLAS-Concepts"><span>GraphBLAS Concepts</span></a></li><li><a class="tocitem" href="#GBArrays"><span>GBArrays</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operations"><span>GraphBLAS Operations</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operators"><span>GraphBLAS Operators</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="arrays/">Arrays</a></li><li><a class="tocitem" href="operations/">Operations</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="operators/">Basics</a></li><li><a class="tocitem" href="unaryops/">Unary Operators</a></li><li><a class="tocitem" href="binaryops/">Binary Operators</a></li><li><a class="tocitem" href="monoids/">Monoids</a></li><li><a class="tocitem" href="semirings/">Semirings</a></li><li><a class="tocitem" href="selectops/">Select Operators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SuiteSparseGraphBLAS.jl"><a class="docs-heading-anchor" href="#SuiteSparseGraphBLAS.jl">SuiteSparseGraphBLAS.jl</a><a id="SuiteSparseGraphBLAS.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SuiteSparseGraphBLAS.jl" title="Permalink"></a></h1><p>SuiteSparseGraphBLAS.jl is a package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis&#39; SuiteSparse reference implementation of the GraphBLAS C specification.</p><h1 id="Roadmap"><a class="docs-heading-anchor" href="#Roadmap">Roadmap</a><a id="Roadmap-1"></a><a class="docs-heading-anchor-permalink" href="#Roadmap" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This library is still very WIP, if you are missing any functionality, or find any incorrectly implemented functions from those interfaces please open an issue or PR!</p></div></div><p>While the core library is mostly complete, and all GraphBLAS functionality is present, there are still quite a few features being worked on for v1.0:</p><ol><li>ChainRules.jl integration for AD.</li><li>Complete SparseArrays and ArrayInterface interfaces.</li><li>Fancy printing</li><li>User-defined types.</li><li>Alternative syntax for GraphBLAS ops (currently must use <code>BinaryOps.PLUS</code> instead of <code>+</code>).</li></ol><p>Once these are completed there will be a v1.0 release, with the goal being JuliaCon 2021.</p><p>Post 1.0 goals include:</p><ol><li>LightGraphs integration.</li><li>GeometricFlux or other graph machine learning framework integration.</li><li>More efficient import and export between Julia and GraphBLAS</li><li>Support for other GraphBLAS implementations in a follow-up GraphBLAS.jl</li></ol><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>Install using the Julia package manager in the REPL:</p><pre><code class="nohighlight">] add SuiteSparseGraphBLAS</code></pre><p>or with <code>Pkg</code></p><pre><code class="nohighlight">using Pkg
Pkg.add(&quot;SuiteSparseGraphBLAS&quot;)</code></pre><p>The SuiteSparse:GraphBLAS binary is installed automatically as <code>SSGraphBLAS_jll</code>.</p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by its <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>, <a href="https://en.wikipedia.org/wiki/Incidence_matrix">incidence matrix</a>, or the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.</p><p>Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.</p><p><img src="assets/AdjacencyBFS.png" alt="BFS and Adjacency Matrix"/></p><h1 id="GraphBLAS-Concepts"><a class="docs-heading-anchor" href="#GraphBLAS-Concepts">GraphBLAS Concepts</a><a id="GraphBLAS-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Concepts" title="Permalink"></a></h1><p>The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.</p><h2 id="GBArrays"><a class="docs-heading-anchor" href="#GBArrays">GBArrays</a><a id="GBArrays-1"></a><a class="docs-heading-anchor-permalink" href="#GBArrays" title="Permalink"></a></h2><p>SuiteSparseGraphBLAS.jl provides <code>GBVector</code> and <code>GBMatrix</code> array types which are subtypes of <code>SparseArrays.AbstractSparseVector</code> and <code>SparseArrays.AbstractSparseMatrix</code> respectively. Both can be constructed with no arguments to use the maximum size.</p><pre><code class="language-julia-repl">julia&gt; GBVector{Float64}()
1152921504606846976x1 GraphBLAS double vector, sparse by col
  no entries, memory: 272 bytes

julia&gt; GBMatrix{ComplexF64}()
1152921504606846976x1152921504606846976 GraphBLAS double complex matrix, hypersparse by col
  no entries, memory: 280 bytes</code></pre><p>GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation. SuiteSparseGraphBLAS.jl sets the default to column major to ensure fast imports and exports.</p><p>A complete list of construction methods can be found in <a href="@ref">Construction</a>, but the matrix and vector above can be constructed as follows:</p><pre><code class="language-julia-repl">julia&gt; A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])
7x7 GraphBLAS int64_t matrix, bitmap by col
  12 entries, memory: 832 bytes

    (4,1)   6
    (1,2)   1
    (4,3)   7
    (6,3)   9
    (7,3)   10
    (1,4)   2
    (7,4)   11
    (2,5)   3
    (7,5)   12
    (3,6)   5
    (5,6)   8
    (2,7)   4

julia&gt; v = GBVector([4], [10])
4x1 GraphBLAS int64_t vector, bitmap by col
  1 entry, memory: 272 bytes
  iso value:   10

    (4,1)   10</code></pre><h2 id="GraphBLAS-Operations"><a class="docs-heading-anchor" href="#GraphBLAS-Operations">GraphBLAS Operations</a><a id="GraphBLAS-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operations" title="Permalink"></a></h2><p>The complete documentation of supported operations can be found in <a href="operations/#Operations">Operations</a>. GraphBLAS operations are, where possible, methods of existing Julia functions  listed in the third column.</p><table><tr><th style="text-align: left">GraphBLAS</th><th style="text-align: center">Operation</th><th style="text-align: right">Julia</th></tr><tr><td style="text-align: left"><code>mxm</code>, <code>mxv</code>, <code>vxm</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot AB$</span></td><td style="text-align: right"><code>mul[!]</code></td></tr><tr><td style="text-align: left"><code>eWiseMult</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \otimes B)$</span></td><td style="text-align: right"><code>emul[!]</code></td></tr><tr><td style="text-align: left"><code>eWiseAdd</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \oplus  B)$</span></td><td style="text-align: right"><code>eadd[!]</code></td></tr><tr><td style="text-align: left"><code>extract</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A(I,J)$</span></td><td style="text-align: right"><code>extract[!]</code>, <code>getindex</code></td></tr><tr><td style="text-align: left"><code>subassign</code></td><td style="text-align: center"><span>$\bf C (I,J) \langle M \rangle = C(I,J) \odot A$</span></td><td style="text-align: right"><code>subassign[!]</code>, <code>setindex!</code></td></tr><tr><td style="text-align: left"><code>assign</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle (I,J) = C(I,J) \odot A$</span></td><td style="text-align: right"><code>assign[!]</code></td></tr><tr><td style="text-align: left"><code>apply</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f{\bf (A)}$</span></td><td style="text-align: right"><code>map[!]</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},y)$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f(x,{\bf A})$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>select</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},k)$</span></td><td style="text-align: right"><code>select[!]</code></td></tr><tr><td style="text-align: left"><code>reduce</code></td><td style="text-align: center"><span>${\bf w \langle m \rangle = w \odot} [{\oplus}_j {\bf A}(:,j)]$</span></td><td style="text-align: right"><code>reduce[!]</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>$s = s \odot [{\oplus}_{ij}  {\bf A}(i,j)]$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>transpose</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A^{\sf T}$</span></td><td style="text-align: right"><code>gbtranspose[!]</code>, lazy: <code>transpose</code>, <code>&#39;</code></td></tr><tr><td style="text-align: left"><code>kronecker</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot \text{kron}(A, B)$</span></td><td style="text-align: right"><code>kron[!]</code></td></tr></table><p>where <span>$\bf M$</span> is a <code>GBArray</code> mask, <span>$\odot$</span> is a binary operator for accumulating into <span>$\bf C$</span>, and <span>$\otimes$</span> and <span>$\oplus$</span> are a binary operation and commutative monoid respectively. </p><h2 id="GraphBLAS-Operators"><a class="docs-heading-anchor" href="#GraphBLAS-Operators">GraphBLAS Operators</a><a id="GraphBLAS-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operators" title="Permalink"></a></h2><p>GraphBLAS operators are one of the following:</p><ul><li><code>UnaryOps</code> such as <code>SIN</code>, <code>SQRT</code>, <code>ABS</code>, ...</li><li><code>BinaryOps</code> such as <code>GE</code>, <code>MAX</code>, <code>POW</code>, <code>FIRSTJ</code>, ...</li><li><code>Monoids</code> such as <code>PLUS_MONOID</code>, <code>LXOR_MONOID</code>, ...</li><li><code>Semirings</code> such as <code>PLUS_TIMES</code> (the arithmetic semiring), <code>MAX_PLUS</code> (a tropical semiring), <code>PLUS_PLUS</code>, ...</li></ul><p>Built-in operators can be found in exported submodules:</p><pre><code class="language-julia">julia&gt; BinaryOps.\TAB

ANY       BSET       DIV        FIRSTJ1    ISGE       LDEXP      MIN        RDIV       SECONDJ
ATAN2     BSHIFT     EQ         FMOD       ISGT       LE         MINUS      REMAINDER  SECONDJ1
BAND      BXNOR      FIRST      GE         ISLE       LOR        NE         RMINUS     TIMES
BCLR      BXOR       FIRSTI     GT         ISLT       LT         PAIR       SECOND
BGET      CMPLX      FIRSTI1    HYPOT      ISNE       LXOR       PLUS       SECONDI
BOR       COPYSIGN   FIRSTJ     ISEQ       LAND       MAX        POW        SECONDI1</code></pre><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here is an example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph <a href="https://github.com/GraphBLAS/LAGraph">repo</a>.</p><p>Input <code>A</code> must be a square, symmetric matrix with any element type. We&#39;ll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.</p><pre><code class="language-julia-repl">julia&gt; function cohen(A)
         U = select(SelectOps.TRIU, A)
         L = select(SelectOps.TRIL, A)
         return reduce(Monoids.PLUS_MONOID[Int64], mul(L, U, Semirings.PLUS_PAIR; mask=A)) ÷ 2
       end
cohen (generic function with 1 method)

julia&gt; function sandia(A)
         L = select(SelectOps.TRIL, A)
         return reduce(Monoids.PLUS_MONOID[Int64], mul(L, L, Semirings.PLUS_PAIR; mask=L))
       end
sandia (generic function with 1 method)

julia&gt; M = eadd(A, A&#39;, BinaryOps.PLUS) #Make undirected/symmetric
7x7 GraphBLAS int64_t matrix, bitmap by col
  20 entries, memory: 832 bytes

    (2,1)   1
    (4,1)   8
    (1,2)   1
    (5,2)   3
    (7,2)   4
    (4,3)   7
    (6,3)   14
    (7,3)   10
    (1,4)   8
    (3,4)   7
    (7,4)   11
    (2,5)   3
    (6,5)   8
    (7,5)   12
    (3,6)   14
    (5,6)   8
    (2,7)   4
    (3,7)   10
    (4,7)   11
    (5,7)   12

julia&gt; cohen(M)
2

julia&gt; sandia(M)
2</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="arrays/">Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Friday 2 July 2021 03:44">Friday 2 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
