var documenterSearchIndex = {"docs":
[{"location":"unaryops/#Unary-Operators","page":"Unary Operators","title":"Unary Operators","text":"","category":"section"},{"location":"unaryops/#Built-Ins","page":"Unary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"unaryops.jl\"]","category":"page"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ABS","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ABS","text":"Absolute Value: z=|x|\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ACOS","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ACOS","text":"Inverse Cosine: z=cos⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ACOSH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ACOSH","text":"Inverse Hyperbolic Cosine: z=cosh⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.AINV","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.AINV","text":"Additive Inverse: z=-x\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ASIN","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ASIN","text":"Inverse Sine: z=sin⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ASINH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ASINH","text":"Inverse Hyperbolic Sine: z=sinh⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ATAN","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ATAN","text":"Inverse Tangent: z=tan⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ATANH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ATANH","text":"Inverse Hyperbolic Tangent: z=tanh⁻¹(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.BNOT","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.BNOT","text":"Bitwise Negation: z=¬x\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.CARG","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.CARG","text":"Angle: z=carg(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.CEIL","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.CEIL","text":"Ceiling Function: z=⌈x⌉\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.CIMAG","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.CIMAG","text":"Imaginary Part: z=imag(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.CONJ","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.CONJ","text":"Complex Conjugate: z=x̄\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.COS","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.COS","text":"Cosine: z=cos(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.COSH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.COSH","text":"Hyperbolic Cosine: z=cosh(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.CREAL","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.CREAL","text":"Real Part: z=real(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ERF","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ERF","text":"Error Function: z=erf(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ERFC","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ERFC","text":"Complimentary Error Function: z=erfc(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.EXP","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.EXP","text":"Natural Base Exponential: z=eˣ\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.EXP2","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.EXP2","text":"Base-2 Exponential: z=2ˣ\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.EXPM1","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.EXPM1","text":"Natural Exponential - 1: z=eˣ - 1\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.FLOOR","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.FLOOR","text":"Floor Function: z=⌊x⌋\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.FREXPE","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.FREXPE","text":"Normalized Exponent: z=frexpe(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.FREXPX","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.FREXPX","text":"Normalized Fraction: z=frexpx(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.IDENTITY","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.IDENTITY","text":"Identity: z=x\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ISFINITE","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ISFINITE","text":"isfinite: z=isfinite(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ISINF","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ISINF","text":"isinf: z=(x == ±∞)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ISNAN","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ISNAN","text":"isnan: z=(x == NaN)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LGAMMA","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LGAMMA","text":"Log of Gamma Function: z=log(|Γ(x)|)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LNOT","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LNOT","text":"Logical Negation\n\nz=¬x::Bool\n\nReal:  z=¬(x::ℝ ≠ 0)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LOG","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LOG","text":"Natural Logarithm: z=logₑ(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LOG10","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LOG10","text":"Log Base 10: z=log₁₀(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LOG1P","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LOG1P","text":"Natural Log of x + 1: z=logₑ(x + 1)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.LOG2","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.LOG2","text":"Log Base 2: z=log₂(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.MINV","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.MINV","text":"Multiplicative Inverse: z=1/x\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ONE","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ONE","text":"One: z=one(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.POSITIONI","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.POSITIONI","text":"0-based Row Index: z=i\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.POSITIONI1","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.POSITIONI1","text":"1-Based Row Index: z=i + 1\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.POSITIONJ","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.POSITIONJ","text":"0-Based Column Index: z=j\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.POSITIONJ1","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.POSITIONJ1","text":"1-Based Column Index: z=j + 1\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.ROUND","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.ROUND","text":"Round to nearest: z=round(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.SIGNUM","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.SIGNUM","text":"Sign Function: z=signum(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.SIN","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.SIN","text":"Sine: z=sin(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.SINH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.SINH","text":"Hyperbolic Sine: z=sinh(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.SQRT","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.SQRT","text":"Square Root: z=√(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.TAN","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.TAN","text":"Tangent: z=tan(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.TANH","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.TANH","text":"Hyperbolic Tangent: z=tanh(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.TGAMMA","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.TGAMMA","text":"Gamma Function: z=Γ(x)\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#SuiteSparseGraphBLAS.UnaryOps.TRUNC","page":"Unary Operators","title":"SuiteSparseGraphBLAS.UnaryOps.TRUNC","text":"Truncate: z=trunc(x)\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#Select-Operators","page":"Select Operators","title":"Select Operators","text":"","category":"section"},{"location":"selectops/#About","page":"Select Operators","title":"About","text":"","category":"section"},{"location":"selectops/#Built-Ins","page":"Select Operators","title":"Built-Ins","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"selectops.jl\"]","category":"page"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.DIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.DIAG","text":"select(SelectOps.DIAG, A, k=0)\n\nSelect the entries on the kth diagonal of A.\n\nSee also: LinearAlgebra.TRIU\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.EQ","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.EQ","text":"select(SelectOps.EQ, A, k)\n\nSelect all entries equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.EQ_ZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.EQ_ZERO","text":"select(SelectOps.NONZERO, A)\n\nSelect all entries in A equal to zero.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.GE","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.GE","text":"select(SelectOps.GE, A, k)\n\nSelect all entries greater than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.GE_ZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.GE_ZERO","text":"select(SelectOps.GT_ZERO, A)\n\nSelect all entries in A greater than or equal to zero.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.GT","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.GT","text":"select(SelectOps.GT, A, k)\n\nSelect all entries greater than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.GT_ZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.GT_ZERO","text":"select(SelectOps.EQ_ZERO, A)\n\nSelect all entries in A greater than zero.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.LE","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.LE","text":"select(SelectOps.LE, A, k)\n\nSelect all entries less than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.LE_ZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.LE_ZERO","text":"select(SelectOps.LE_ZERO, A)\n\nSelect all entries in A less than or equal to zero.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.LT","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.LT","text":"select(SelectOps.LT, A, k)\n\nSelect all entries less than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.LT_ZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.LT_ZERO","text":"select(SelectOps.GE_ZERO, A)\n\nSelect all entries in A less than zero.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.NE","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.NE","text":"select(SelectOps.NE, A, k)\n\nSelect all entries not equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.NONZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.NONZERO","text":"select(SelectOps.NONZERO, A)\n\nSelect all entries in A with nonzero value.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.OFFDIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.OFFDIAG","text":"select(SelectOps.OFFDIAG, A, k=0)\n\nSelect the entries not on the kth diagonal of A.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.TRIL","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.TRIL","text":"select(SelectOps.TRIL, A, k=0)\n\nSelect the entries on or below the kth diagonal of A.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.SelectOps.TRIU","page":"Select Operators","title":"SuiteSparseGraphBLAS.SelectOps.TRIU","text":"select(SelectOps.TRIU, A, k=0)\n\nSelect the entries on or above the kth diagonal of A.\n\nSee also: LinearAlgebra.TRIL\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#Binary-Operators","page":"Binary Operators","title":"Binary Operators","text":"","category":"section"},{"location":"binaryops/#Built-Ins","page":"Binary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"binaryops.jl\"]","category":"page"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ANY","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ANY","text":"Pick x or y arbitrarily: f(x::T,y::T)::T = x or y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ATAN2","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ATAN2","text":"4-Quadrant Arc Tangent: f(x::F, y::F)::F = tan⁻¹(y/x)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BAND","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BAND","text":"Bitwise AND: f(x::ℤ, y::ℤ)::ℤ = x & y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BCLR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BCLR","text":"BCLR: f(x::ℤ, y::ℤ)::ℤ = clear bit y of x.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BGET","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BGET","text":"BGET: f(x::ℤ, y::ℤ)::ℤ = get bit y of x.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BOR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BOR","text":"Bitwise OR: f(x::ℤ, y::ℤ)::ℤ = x | y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BSET","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BSET","text":"BSET: f(x::ℤ, y::ℤ)::ℤ = set bit y of x.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BSHIFT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BSHIFT","text":"BSHIFT: f(x::ℤ, y::Int8)::ℤ = bitshift(x, y)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BXNOR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BXNOR","text":"Bitwise XNOR: : f(x::ℤ, y::ℤ)::ℤ = ~(x ^ y)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.BXOR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.BXOR","text":"Bitwise XOR: f(x::ℤ, y::ℤ)::ℤ = x ^ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.CMPLX","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.CMPLX","text":"Complex: f(x::F, y::F)::Complex = x + y × i\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.COPYSIGN","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.COPYSIGN","text":"Copysign: Value with magnitude of x and sign of y.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.DIV","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.DIV","text":"Division: f(x::T,y::T)::T = x / y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.EQ","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.EQ","text":"Equals: f(x::T, y::T)::Bool = x == y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FIRST","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FIRST","text":"First argument: f(x::T,y::T)::T = x\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FIRSTI","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FIRSTI","text":"0-Based row index of a: f(aᵢⱼ::T, bₖₗ::T)::Int64 = i\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FIRSTI1","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FIRSTI1","text":"1-Based row index of a: f(aᵢⱼ::T, bₖₗ::T)::Int64 = i + 1\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FIRSTJ","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FIRSTJ","text":"0-Based column index of a: f(aᵢⱼ::T, bₖₗ::T)::Int64 = j\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FIRSTJ1","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FIRSTJ1","text":"1-Based column index of a: f(aᵢⱼ::T, bₖₗ::T)::Int64 = j + 1\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.FMOD","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.FMOD","text":"Float remainder of x / y rounded towards zero.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.GE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.GE","text":"Greater Than or Equal: f(x::T, y::T)::Bool = x ≥ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.GT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.GT","text":"Greater Than: f(x::T, y::T)::Bool = x > y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.HYPOT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.HYPOT","text":"Hypotenuse: f(x::F, y::F)::F = √(x² + y²)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISEQ","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISEQ","text":"Equal: f(x::T,y::T)::T = x == y`\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISGE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISGE","text":"Greater Than or Equal: f(x::ℝ,y::ℝ)::ℝ = x ≥ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISGT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISGT","text":"Greater Than: f(x::ℝ,y::ℝ)::ℝ = x > y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISLE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISLE","text":"Less Than or Equal: f(x::ℝ,y::ℝ)::ℝ = x ≤ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISLT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISLT","text":"Less Than: f(x::ℝ,y::ℝ)::ℝ = x < y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.ISNE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.ISNE","text":"Not Equal: f(x::T,y::T)::T = x ≠ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LAND","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LAND","text":"Logical AND: f(x::ℝ,y::ℝ)::ℝ = (x ≠ 0) ∧ (y ≠ 0)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LDEXP","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LDEXP","text":"LDEXP: f(x::F, y::F)::F = x × 2ⁿ\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LE","text":"Less Than or Equal: f(x::T, y::T)::Bool = x ≤ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LOR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LOR","text":"Logical OR: f(x::ℝ,y::ℝ)::ℝ = (x ≠ 0) ∨ (y ≠ 0)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LT","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LT","text":"Less Than: f(x::T, y::T)::Bool = x < y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.LXOR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.LXOR","text":"Logical AND: f(x::ℝ,y::ℝ)::ℝ = (x ≠ 0) ⊻ (y ≠ 0)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.MAX","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.MAX","text":"Maximum: f(x::ℝ,y::ℝ)::ℝ = max(x, y)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.MIN","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.MIN","text":"Minimum: f(x::ℝ,y::ℝ)::ℝ = min(x, y)\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.MINUS","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.MINUS","text":"Subtraction: f(x::T,y::T)::T = x - y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.NE","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.NE","text":"Not Equals: f(x::T, y::T)::Bool = x ≠ y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.PAIR","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.PAIR","text":"One when both x and y exist: f(x::T,y::T)::T = 1\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.PLUS","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.PLUS","text":"Addition: f(x::T,y::T)::T = x + y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.POW","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.POW","text":"Power: f(x::T,y::T)::T = xʸ\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.RDIV","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.RDIV","text":"Reverse Division: f(x::T,y::T)::T = y / x\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.REMAINDER","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.REMAINDER","text":"Float remainder of x / y rounded towards nearest integral value.\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.RMINUS","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.RMINUS","text":"Reverse Subtraction: f(x::T,y::T)::T = y - x\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.SECOND","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.SECOND","text":"Second argument: f(x::T,y::T)::T = y\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.SECONDI","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.SECONDI","text":"0-Based row index of b: f(aᵢⱼ::T, bₖₗ::T)::Int64 = k\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.SECONDI1","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.SECONDI1","text":"0-Based row index of b: f(aᵢⱼ::T, bₖₗ::T)::Int64 = k + 1\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.SECONDJ","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.SECONDJ","text":"0-Based column index of b: f(aᵢⱼ::T, bₖₗ::T)::Int64 = l\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.SECONDJ1","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.SECONDJ1","text":"1-Based column index of b: f(aᵢⱼ::T, bₖₗ::T)::Int64 = l + 1\n\n\n\n\n\n","category":"constant"},{"location":"binaryops/#SuiteSparseGraphBLAS.BinaryOps.TIMES","page":"Binary Operators","title":"SuiteSparseGraphBLAS.BinaryOps.TIMES","text":"Multiplication: f(x::T,y::T)::T = xy\n\n\n\n\n\n","category":"constant"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"semirings/#Semirings","page":"Semirings","title":"Semirings","text":"","category":"section"},{"location":"semirings/#About","page":"Semirings","title":"About","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring in GraphBLAS is a domain T along with two binary operators. The first, oplus or \"add\" is a commutative and associative monoid. The second, otimes or \"multiply\", is a binary operator z = f(x, y) such that the monoid type matches the type of z.","category":"page"},{"location":"semirings/#Built-Ins","page":"Semirings","title":"Built-Ins","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"using Pkg\nPkg.activate(\"..\")\ncd(\"..\")\nusing SuiteSparseGraphBLAS\nusing Latexify\nhead = [\"Semiring\", \"⊕\", \"⊗\", \"Types\"]\nv1 = filter((x) -> x != \"Semirings\", string.(names(Semirings)))\nv2 = \"[\" .* getindex.(split.(v1, '_'),1) .* \"_MONOID](@ref)\"\nv3 = \"[\" .* getindex.(split.(v1, '_'), 2) .* \"](@ref)\"\nv4 = []\nv1 = \"`\" .* v1 .* \"`\"\nfor op in names(Semirings)\n    op == :Semirings && continue\n    op = getproperty(Semirings, op)\n    push!(v4, SuiteSparseGraphBLAS.validtypes(op))\nend\nLatexify.mdtable(hcat(v1,v2,v3,v4); head, latex=false)","category":"page"},{"location":"monoids/#Monoids","page":"Monoids","title":"Monoids","text":"","category":"section"},{"location":"monoids/#About","page":"Monoids","title":"About","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"A monoid is made up of a set or domain T and a binary operator z = f(x y) operating on the same domain, T times T rightarrow T. This binary operator must be associative, that is f(a f(b c)) = f(f(a b) c) is always true. Associativity is important for operations like reduce and the multiplication step of mul.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The operator must also be equipped with an identity such that f(x 0) = f(0 x) = x. Some monoids are equipped with a terminal or annihilator such that z = f(z x) forall x.","category":"page"},{"location":"monoids/#Built-Ins","page":"Monoids","title":"Built-Ins","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"note: Note\nIn the case of floating point numbers +∞ and -∞ have their typical meanings. However, for integer types they indicate typemax and typemin respectively.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"monoids.jl\"]","category":"page"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.ANY_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.ANY_MONOID","text":"Any monoid: f(x::T, y::T)::T = x or y\n\nIdentity: any\nTerminal: any\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BAND_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BAND_MONOID","text":"Bitwise AND monoid: f(x::ℤ, y::ℤ)::ℤ = x&y\n\nIdentity: All bits 1.\nTerminal: All bits 0.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BOR_MONOID","text":"Bitwise OR monoid: f(x::ℤ, y::ℤ)::ℤ = x|y\n\nIdentity: All bits 0.* Terminal: All bits 1.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BXNOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BXNOR_MONOID","text":"Bitwise XNOR monoid: f(x::ℤ, y::ℤ)::ℤ = ~(x^y)\n\nIdentity: All bits 1.\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BXOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BXOR_MONOID","text":"Bitwise XOR monoid: f(x::ℤ, y::ℤ)::ℤ = x^y\n\nIdentity: All bits 0.\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.EQ_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.EQ_MONOID","text":"Equivalent to LXNOR monoid.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LAND_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LAND_MONOID","text":"Logical AND monoid: f(x::Bool, y::Bool)::Bool = x ∧ y\n\nIdentity: true\nTerminal: false\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LOR_MONOID","text":"Logical OR monoid: f(x::Bool, y::Bool)::Bool = x ∨ y\n\nIdentity: false\nTerminal: true\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LXNOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LXNOR_MONOID","text":"Logical XNOR monoid: f(x::Bool, y::Bool)::Bool = x == y\n\nIdentity: true\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LXOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LXOR_MONOID","text":"Logical XOR monoid: f(x::Bool, y::Bool)::Bool = x ⊻ y\n\nIdentity: false\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.MAX_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.MAX_MONOID","text":"Max monoid: f(x::ℝ, y::ℝ)::ℝ = max(x, y)\n\nIdentity: -∞\nTerminal: +∞\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.MIN_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.MIN_MONOID","text":"Minimum monoid: f(x::ℝ, y::ℝ)::ℝ = min(x, y)\n\nIdentity: +∞\nTerminal: -∞\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.PLUS_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.PLUS_MONOID","text":"Plus monoid: f(x::T, y::T)::T = x + y\n\nIdentity: 0\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.TIMES_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.TIMES_MONOID","text":"Times monoid: f(x::T, y::T)::T = xy\n\nIdentity: 1\nTerminal: 0 for non Floating-point numbers.\n\n\n\n\n\n","category":"constant"},{"location":"#SuiteSparseGraphBLAS.jl","page":"Introduction","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl is a WIP package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis' SuiteSparse reference implementation of the GraphBLAS C specification.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"While the core library is mostly complete, and all GraphBLAS functionality is present, there are still quite a few features being worked on for v1.0:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ChainRules.jl integration for AD.\nComplete SparseArrays and ArrayInterface interfaces.\nPrinting v2.\nUser-defined types and functions.\nAlternative syntax for GraphBLAS ops (currently must use BinaryOps.PLUS instead of +).\nComplex builtins.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once these are completed there will be a v1.0 release, with the goal being JuliaCon 2021.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Post 1.0 goals include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"LightGraphs integration.\nGeometricFlux or other graph machine learning framework integration.\nMore efficient import and export between Julia and GraphBLAS\nSupport for other GraphBLAS implementations in a follow-up GraphBLAS.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"danger: Printing\nPrinting is done directly by GraphBLAS in this release. This means printed indices are 0-based, and the displayed type is the equivalent C type. The v1.0 release will alleviate this issue.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install using the Julia package manager in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add SuiteSparseGraphBLAS#master","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with Pkg","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"SuiteSparseGraphBLAS\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The SuiteSparse:GraphBLAS binary is installed automatically as SSGraphBLAS_jll.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by its adjacency matrix, incidence matrix, or the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: BFS and Adjacency Matrix)","category":"page"},{"location":"#GraphBLAS-Concepts","page":"Introduction","title":"GraphBLAS Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.","category":"page"},{"location":"#GBArrays","page":"Introduction","title":"GBArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl provides GBVector and GBMatrix array types which are subtypes of SparseArrays.AbstractSparseVector and SparseArrays.AbstractSparseMatrix respectively. Both can be constructed with no arguments to use the maximum size.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> GBVector{Float64}()\n1152921504606846976x1 GraphBLAS double vector, sparse by col\n  no entries\n\n1152921504606846976x1152921504606846976 GraphBLAS int8_t matrix, hypersparse by col\n  no entries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation. SuiteSparseGraphBLAS.jl sets the default to column major to ensure fast imports and exports.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A complete list of construction methods can be found in Construction, but the matrix and vector above can be constructed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\n7x7 GraphBLAS int64_t matrix, bitmap by col\n  12 entries\n\n    (3,0)   6\n    (0,1)   1\n    (3,2)   7\n    (5,2)   9\n    (6,2)   10\n    (0,3)   2\n    (6,3)   11\n    (1,4)   3\n    (6,4)   12\n    (2,5)   5\n    (4,5)   8\n    (1,6)   4\n\nv = GBVector([4], [10])\n4x1 GraphBLAS int64_t vector, bitmap by col\n  1 entry\n\n    (3,0)   10","category":"page"},{"location":"#GraphBLAS-Operations","page":"Introduction","title":"GraphBLAS Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The complete documentation of supported operations can be found in Operations. GraphBLAS operations are, where possible, methods of existing Julia functions  listed in the third column.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"#Common-arguments","page":"Introduction","title":"Common arguments","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The operations above have often accept most or all of the following arguments.","category":"page"},{"location":"#op-UnaryOp,-BinaryOp,-Monoid,-Semiring,-or-SelectOp:","page":"Introduction","title":"op - UnaryOp, BinaryOp, Monoid, Semiring, or SelectOp:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the most important argument for most of these operations. It determines oplus, otimes, or f in the table above as well as the semiring used in mul. Most operations are restricted to one type of operator.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Built-Ins\nThe built-in operators can be found in the submodules: UnaryOps, BinaryOps, Monoids, and Semirings.","category":"page"},{"location":"#desc-Descriptor:","page":"Introduction","title":"desc - Descriptor:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The descriptor argument allows the user to modify the operation in some fashion. The most common options are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"desc.[input1 | input2] == [DEFAULT | TRANSPOSE] \nTransposes the inputs and can be found in Descriptors.[T0 | T1 | T0T1].    Typically you should use Julia's built-in transpose functionality.\ndesc.mask == [DEFAULT | STRUCTURE | COMPLEMENT | STRUCT_COMP] \nIf STRUCTURE is set the operation will use the presence of a value rather than the value itself to determine whether the index is masked.    If COMPLEMENT is set the presence/truth value is complemented (ie. if no value is present or the value is false that index is masked).\ndesc.output == [DEFAULT | REPLACE]\nIf REPLACE is set the operation will replace all values in the output matrix after the accumulation step.    If an index is found in the output matrix, but not in the results of the operation it will be set to nothing. ","category":"page"},{"location":"#accum-BinaryOp:","page":"Introduction","title":"accum - BinaryOp:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The accum keyword argument provides a binary operation to accumulate results into the result array.  The accumulation step is performed before masking.","category":"page"},{"location":"#mask-GBArray:","page":"Introduction","title":"mask - GBArray:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The mask keyword argument determines whether each index from the result of an operation appears in the output.  The mask may be structural, where the presence of a value indicates the mask is true, or valued where the value of the mask indicates its truth value.  The mask may also be complemented. These options are controlled by the desc argument.","category":"page"},{"location":"#GraphBLAS-Operators","page":"Introduction","title":"GraphBLAS Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS operators are one of the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"UnaryOps such as SIN, SQRT, ABS, ...\nBinaryOps such as GE, MAX, POW, FIRSTJ, ...\nMonoids such as PLUS_MONOID, LXOR_MONOID, ...\nSemirings such as PLUS_TIMES (the arithmetic semiring), MAX_PLUS (a tropical semiring), PLUS_PLUS, ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Built-in operators can be found in exported submodules:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> BinaryOps.\n\nANY       BSET       DIV        FIRSTJ1    ISGE       LDEXP      MIN        RDIV       SECONDJ\nATAN2     BSHIFT     EQ         FMOD       ISGT       LE         MINUS      REMAINDER  SECONDJ1\nBAND      BXNOR      FIRST      GE         ISLE       LOR        NE         RMINUS     TIMES\nBCLR      BXOR       FIRSTI     GT         ISLT       LT         PAIR       SECOND\nBGET      CMPLX      FIRSTI1    HYPOT      ISNE       LXOR       PLUS       SECONDI\nBOR       COPYSIGN   FIRSTJ     ISEQ       LAND       MAX        POW        SECONDI1","category":"page"},{"location":"#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is an example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph repo.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Input A must be a square, symmetric matrix with any element type. We'll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function cohen(A)\n  U = select(SelectOps.TRIU, A)\n  L = select(SelectOps.TRIL, A)\n  return reduce(Monoids.PLUS_MONOID[Int64], mul(L, U, Semirings.PLUS_PAIR; mask=A)) ÷ 2\nend\n\nfunction sandia(A)\n  L = select(SelectOps.TRIL, A)\n  return reduce(Monoids.PLUS_MONOID[Int64], mul(L, L, Semirings.PLUS_PAIR; mask=L))\nend\n\nM = eadd(A, A', BinaryOps.PLUS) #Make undirected/symmetric\ncohen(A) # 2\nsandia(A) # 2","category":"page"},{"location":"arrays/#GBArrays","page":"Arrays","title":"GBArrays","text":"","category":"section"},{"location":"arrays/#Construction","page":"Arrays","title":"Construction","text":"","category":"section"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS operations cover most of the typical linear algebra operations on arrays in Julia.","category":"page"},{"location":"operations/#Correspondence-of-GraphBLAS-C-functions-and-Julia-functions","page":"Operations","title":"Correspondence of GraphBLAS C functions and Julia functions","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: assign vs subassign\nsubassign is equivalent to assign except that the mask in subassign has the dimensions of bf C(IJ) vs the dimensions of C for assign, and elements outside of the mask will never be modified by subassign. See the GraphBLAS User Guide for more details.","category":"page"},{"location":"operations/#Order-of-Operations","page":"Operations","title":"Order of Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A GraphBLAS operation occurs in the following order (steps are skipped when possible):","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Calculate T = <operation>(args...)\nElementwise accumulate Z[i,j] = accum(C[i,j], T[i,j])\nOptionally masked assignment C[i,j] = mask[i,j] ? Z[i,j] : [nothing | C[i,j]]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If REPLACE is set the option in step 3. is nothing, otherwise it is C[i,j].","category":"page"},{"location":"operations/#Operation-Documentation","page":"Operations","title":"Operation Documentation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"mul\nemul\neadd\nextract\nextract!\nsubassign!\nassign!\nBase.map(::SuiteSparseGraphBLAS.AbstractOp, ::SuiteSparseGraphBLAS.GBArray, ::Any)\nselect\nBase.reduce\ngbtranspose\nLinearAlgebra.kron","category":"page"},{"location":"operations/#SuiteSparseGraphBLAS.mul","page":"Operations","title":"SuiteSparseGraphBLAS.mul","text":"mul(A::GBArray, B::GBArray; kwargs...)::GBArray\n\nMultiply two GBArrays A and B using a semiring provided in the op keyword argument. If either A or B is a GBMatrix it may be transposed either using the descriptor or by using transpose(A) or A'.\n\nThe default semiring is the +.* semiring.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and B or the semiring   if a type specific semiring is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.emul","page":"Operations","title":"SuiteSparseGraphBLAS.emul","text":"emul(A::GBArray, B::GBArray, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nApply the binary operator op elementwise on the set intersection of A and B. Store or accumulate the result into C. When op = BinaryOps.TIMES this is equivalent to A .* B, however any binary operation may be substituted.\n\nAs mentioned the pattern of the result is the set intersection of A and B. For a set union equivalent see eadd.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd","page":"Operations","title":"SuiteSparseGraphBLAS.eadd","text":"eadd(A::GBArray, B::GBArray, op = BinaryOps.PLUS; kwargs...)::GBArray\n\nApply the binary operator op elementwise on the set union of A and B. Store or accumulate the result into C. When op = BinaryOps.TIMES this is equivalent to A .* B, however any binary operation may be substituted.\n\nAs mentioned the pattern of the result is the set union of A and B. For a set intersection equivalent see emul.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\nop::MonoidBinaryOrRig = BinaryOps.PLUS: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A or B.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.extract","page":"Operations","title":"SuiteSparseGraphBLAS.extract","text":"extract(u::GBVector, I; kwargs...)::GBVector\n\nExtract a subvector from u and return it. Equivalent to the matrix definition.\n\n\n\n\n\nextract(A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nExtract a submatrix from A.\n\nArguments\n\nA::GBMatrix: the array being indexed.\nI and J: A colon, scalar, vector, or range indexing A.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == (max(I), max(J)).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied. C is, however, empty.\ndesc::Descriptor = Descriptors.NULL\n\nReturns\n\nGBMatrix: the submatrix A[I, J].\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If (max(I), max(J)) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.extract!","page":"Operations","title":"SuiteSparseGraphBLAS.extract!","text":"extract!(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nExtract a subvector from u into the output vector w. Equivalent to the matrix definition.\n\n\n\n\n\nextract!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nExtract a submatrix from A into C.\n\nArguments\n\nC::GBMatrix: the submatrix extracted from A. It is a dimension mismatch if   size(C) != (max(I), max(J)).\nA::GBMatrix: the array being indexed.\nI and J: A colon, scalar, vector, or range indexing A.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == (max(I), max(J)).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = Descriptors.NULL\n\nReturns\n\nGBMatrix: the modified matrix C, now containing the submatrix A[I, J].\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(C) != (max(I), max(J)) or size(C) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.subassign!","page":"Operations","title":"SuiteSparseGraphBLAS.subassign!","text":"subassign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nsubassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of C to A. Equivalent to assign! except that size(mask) == size(A), whereas size(mask) == size(C) in assign!.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == size(A).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = Descriptors.NULL\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(A) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.assign!","page":"Operations","title":"SuiteSparseGraphBLAS.assign!","text":"assign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of C to A. Equivalent to subassign! except that size(mask) == size(C), whereas size(mask) == size(A) insubassign!`.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == size(C).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = Descriptors.NULL\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(C) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.map-Tuple{SuiteSparseGraphBLAS.AbstractOp, Union{Transpose{var\"#s806\", var\"#s805\"} where {var\"#s806\", var\"#s805\"<:GBMatrix}, GBMatrix, GBVector}, Any}","page":"Operations","title":"Base.map","text":"map(op::UnaryOp, A::GBArray; kwargs...)::GBArray\nmap(op::BinaryOp, A::GBArray, x; kwargs...)::GBArray\nmap(op::BinaryOp, x, A::GBArray, kwargs...)::GBArray\n\nTransform a GBArray by applying op to each element.\n\nUnaryOps apply elementwise in the usual fashion. BinaryOps require the additional argument x which is substituted as the first or second argument of op depending on its position.\n\nArguments\n\nop::MonoidBinaryOrRig = BinaryOps.PLUS: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and/or B.\nA::GBArray: GBVector or optionally transposed GBMatrix.\nx: Position dependent argument to binary operators.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"method"},{"location":"operations/#SuiteSparseGraphBLAS.select","page":"Operations","title":"SuiteSparseGraphBLAS.select","text":"select(op::SelectUnion, A::GBArray; kwargs...)::GBArray\nselect(op::SelectUnion, A::GBArray, thunk; kwargs...)::GBArray\n\nReturn a GBArray whose elements satisfy the predicate defined by op. Some SelectOps may require an additional argument thunk, for use in comparison operations such as C[i,j] = A[i,j] >= thunk ? A[i,j] : nothing, which maps to select(SelectOps.GT_THUNK, A, thunk).\n\nArguments\n\nop::SelectUnion: A select operator from the SelectOps submodule.\nA::GBArray: GBVector or optionally transposed GBMatrix.\nthunk::Union{GBScalar, nothing, valid_union}: Optional value used to evaluate op.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.reduce","page":"Operations","title":"Base.reduce","text":"reduce(op::Monoid, A::GBMatrix, dims=:; kwargs...)\nreduce(op::Monoid, v::GBVector; kwargs...)\n\nReduce A along dimensions of A with monoid op.\n\nArguments\n\nop::MonoidUnion: the monoid reducer. This may not be a BinaryOp.\nA::GBArray: GBVector or optionally transposed GBMatrix.\ndims = :: Optional dimensions for GBMatrix, may be 1, 2, or :.\n\nKeywords\n\ntypeout: Optional output type specification. Defaults to eltype(A).\ninit: Optional initial value.\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.gbtranspose","page":"Operations","title":"SuiteSparseGraphBLAS.gbtranspose","text":"gbtranspose(A::GBMatrix; kwargs...)::GBMatrix\n\nEagerly evaluated matrix transpose which returns the transposed matrix.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: optional mask.\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = Descriptors.NULL\n\nReturns\n\nC::GBMatrix: output matrix.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.kron","page":"Operations","title":"Base.kron","text":"kron(A::GBMatrix, B::GBMatrix, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nKronecker product of two matrices using op as the multiplication operator. Does not support GBVectors at this time.\n\nArguments\n\nA::GBMatrix: optionally transposed.\nB::GBMatrix: optionally transposed.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which replaces the arithmetic   multiplication operation from the usual kron function.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"}]
}
