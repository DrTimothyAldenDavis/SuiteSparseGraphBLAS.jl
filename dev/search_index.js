var documenterSearchIndex = {"docs":
[{"location":"#SuiteSparseGraphBLAS.jl-1","page":"Home","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SuiteSparseGraphBLAS.jl is a Julia wrapper for the SuiteSparse:GraphBLAS C library.","category":"page"},{"location":"context_methods/#Context-methods-1","page":"Context methods","title":"Context methods","text":"","category":"section"},{"location":"context_methods/#","page":"Context methods","title":"Context methods","text":"GrB_init\nGrB_finalize","category":"page"},{"location":"context_methods/#SuiteSparseGraphBLAS.GrB_init","page":"Context methods","title":"SuiteSparseGraphBLAS.GrB_init","text":"GrB_init(mode)\n\nGrB_init must called before any other GraphBLAS operation. GrB_init defines the mode that GraphBLAS will use: blocking or non-blocking. With blocking mode, all operations finish before returning to the user application. With non-blocking mode, operations can be left pending, and are computed only when needed.\n\n\n\n\n\n","category":"function"},{"location":"context_methods/#SuiteSparseGraphBLAS.GrB_finalize","page":"Context methods","title":"SuiteSparseGraphBLAS.GrB_finalize","text":"GrB_finalize()\n\nGrB_finalize must be called as the last GraphBLAS operation. GrB_finalize does not call GrB_wait; any pending computations are abandoned.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Matrix-functions-1","page":"Basic matrix & vector methods","title":"Matrix functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Matrix_new\nGrB_Matrix_build\nGrB_Matrix_nrows\nGrB_Matrix_ncols\nGrB_Matrix_nvals\nGrB_Matrix_setElement\nGrB_Matrix_extractElement\nGrB_Matrix_extractTuples\nGrB_Matrix_dup\nGrB_Matrix_clear","category":"page"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_new","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_new","text":"GrB_Matrix_new(A, type, nrows, ncols)\n\nCreate a new matrix with specified domain and dimensions.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_build","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_build","text":"GrB_Matrix_build(C, I, J, X, nvals, dup)\n\nStore elements from tuples into a matrix.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_nrows","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_nrows","text":"GrB_Matrix_nrows(A)\n\nReturn the number of rows in a matrix if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nrows(MAT)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_ncols","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_ncols","text":"GrB_Matrix_ncols(A)\n\nReturn the number of columns in a matrix if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_ncols(MAT)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_nvals","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_nvals","text":"GrB_Matrix_nvals(A)\n\nReturn the number of stored elements in a matrix if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n5\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_setElement","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_setElement","text":"GrB_Matrix_setElement(C, X, I, J)\n\nSet one element of a matrix to a given value, C[I][J] = X.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n2\n\njulia> GrB_Matrix_setElement(MAT, Int8(7), 1, 1)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_extractElement","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_extractElement","text":"GrB_Matrix_extractElement(A, row_index, col_index)\n\nReturn element of a matrix at a given index (A[rowindex][colindex]) if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, 1, 1)\n2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_extractTuples","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_extractTuples","text":"GrB_Matrix_extractTuples(A)\n\nReturn tuples stored in a matrix.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(MAT)\n([1, 2, 2, 2, 3], [1, 1, 2, 3, 3], Int8[2, 4, 3, 5, 6])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_dup","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_dup","text":"GrB_Matrix_dup(C, A)\n\nCreate a new matrix with the same domain, dimensions, and contents as another matrix.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_dup(B, MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(B, GxB_SHORT)\n\nGraphBLAS matrix: B\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Matrix_clear","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Matrix_clear","text":"GrB_Matrix_clear(A)\n\nRemove all elements from a matrix.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n5\n\njulia> GrB_Matrix_clear(MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Vector-functions-1","page":"Basic matrix & vector methods","title":"Vector functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Vector_new\nGrB_Vector_build\nGrB_Vector_size\nGrB_Vector_nvals\nGrB_Vector_setElement\nGrB_Vector_extractElement\nGrB_Vector_extractTuples\nGrB_Vector_dup\nGrB_Vector_clear","category":"page"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_new","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_new","text":"GrB_Vector_new(v, type, n)\n\nCreate a new vector with specified domain and size.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_build","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_build","text":"GrB_Vector_build(w, I, X, nvals, dup)\n\nStore elements from tuples into a vector.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_SHORT)\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: double 2.1\n    row 2: double 3.2\n    row 3: double 4.4\n\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_size","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_size","text":"GrB_Vector_size(v)\n\nReturn the size of a vector if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_size(V)\n4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_nvals","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_nvals","text":"GrB_Vector_nvals(v)\n\nReturn the number of stored elements in a vector if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_nvals(V)\n3\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_setElement","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_setElement","text":"GrB_Vector_setElement(w, x, i)\n\nSet one element of a vector to a given value, w[i] = x.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n32\n\njulia> GrB_Vector_setElement(V, 7, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_extractElement","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_extractElement","text":"GrB_Vector_extractElement(v, i)\n\nReturn element of a vector at a given index (v[i]) if successful. Else return value of type GrB Info.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, 2)\n3.2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_extractTuples","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_extractTuples","text":"GrB_Vector_extractTuples(v)\n\nReturn tuples stored in a vector.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n([0, 2, 3], [2.1, 3.2, 4.4])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_dup","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_dup","text":"GrB_Vector_dup(w, u)\n\nCreate a new vector with the same domain, size, and contents as another vector.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_dup(B, V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(B, GxB_SHORT)\n\nGraphBLAS vector: B\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 1: int64 2\n    row 2: int64 32\n    row 4: int64 4\n\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#SuiteSparseGraphBLAS.GrB_Vector_clear","page":"Basic matrix & vector methods","title":"SuiteSparseGraphBLAS.GrB_Vector_clear","text":"GrB_Vector_clear(v)\n\nRemove all the elements (tuples) from a vector.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n([1, 2, 4], [2, 32, 4])\n\njulia> GrB_Vector_clear(V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n(Int64[], Int64[])\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Algebra-methods-1","page":"Operators & algebraic structures","title":"Algebra methods","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"GrB_UnaryOp_new\nGrB_BinaryOp_new\nGrB_Monoid_new\nGrB_Semiring_new","category":"page"},{"location":"algebra_methods/#SuiteSparseGraphBLAS.GrB_UnaryOp_new","page":"Operators & algebraic structures","title":"SuiteSparseGraphBLAS.GrB_UnaryOp_new","text":"GrB_UnaryOp_new(op, fn, ztype, xtype)\n\nInitialize a new GraphBLAS unary operator with a specified user-defined function and its types.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> function NEG(a)\n           return -a\n       end\nNEG (generic function with 1 method)\n\njulia> negative = GrB_UnaryOp()\nGrB_UnaryOp\n\njulia> GrB_UnaryOp_new(negative, NEG, GrB_INT64, GrB_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_apply(w, GrB_NULL, GrB_NULL, negative, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 3 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 -10\n    row 2: int64 -20\n\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#SuiteSparseGraphBLAS.GrB_BinaryOp_new","page":"Operators & algebraic structures","title":"SuiteSparseGraphBLAS.GrB_BinaryOp_new","text":"GrB_BinaryOp_new(op, fn, ztype, xtype, ytype)\n\nInitialize a new GraphBLAS binary operator with a specified user-defined function and its types.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 0, 3, 3]; X = [2.1, 3.2, 4.5, 5.0]; n = 4;  # two values at position 0 and 3\n\njulia> dup = GrB_BinaryOp()  # dup is a binary operator which is applied when duplicate values for the same location are present in the vector\nGrB_BinaryOp\n\njulia> function ADD(b, c)\n           return b+c\n       end\nADD (generic function with 1 method)\n\njulia> GrB_BinaryOp_new(dup, ADD, GrB_FP64, GrB_FP64, GrB_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(V, I, X, n, dup)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_SHORT) # the value stored at position 0 and 3 will be the sum of the duplicate values\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: double 5.3\n    row 3: double 9.5\n\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#SuiteSparseGraphBLAS.GrB_Monoid_new","page":"Operators & algebraic structures","title":"SuiteSparseGraphBLAS.GrB_Monoid_new","text":"GrB_Monoid_new(monoid, binary_op, identity)\n\nCreate a new monoid with specified binary operator and identity value.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#SuiteSparseGraphBLAS.GrB_Semiring_new","page":"Operators & algebraic structures","title":"SuiteSparseGraphBLAS.GrB_Semiring_new","text":"GrB_Semiring_new(semiring, monoid, binary_op)\n\nCreate a new semiring with specified monoid and binary operator.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Built-in-algebraic-objects-1","page":"Operators & algebraic structures","title":"Built-in algebraic objects","text":"","category":"section"},{"location":"algebra_methods/#Unary-operators,-z-f(x)-1","page":"Operators & algebraic structures","title":"Unary operators, z = f(x)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"z and x have the same type. The suffix in the name is the type of x and z.\n\nz = x                z = -x            z = 1/x\nidentity             additive          multiplicative\n                     inverse           inverse\n\nGrB_IDENTITY_BOOL    GrB_AINV_BOOL     GrB_MINV_BOOL\nGrB_IDENTITY_INT8    GrB_AINV_INT8     GrB_MINV_INT8\nGrB_IDENTITY_UINT8   GrB_AINV_UINT8    GrB_MINV_UINT8\nGrB_IDENTITY_INT16   GrB_AINV_INT16    GrB_MINV_INT16\nGrB_IDENTITY_UINT16  GrB_AINV_UINT16   GrB_MINV_UINT16\nGrB_IDENTITY_INT32   GrB_AINV_INT32    GrB_MINV_INT32\nGrB_IDENTITY_UINT32  GrB_AINV_UINT32   GrB_MINV_UINT32\nGrB_IDENTITY_INT64   GrB_AINV_INT64    GrB_MINV_INT64\nGrB_IDENTITY_UINT64  GrB_AINV_UINT64   GrB_MINV_UINT64\nGrB_IDENTITY_FP32    GrB_AINV_FP32     GrB_MINV_FP32\nGrB_IDENTITY_FP64    GrB_AINV_FP64     GrB_MINV_FP64\n\nz = !x, where both z and x are boolean. \nThere is no suffix since z and x are only boolean.\n\nGrB_LNOT","category":"page"},{"location":"algebra_methods/#Binary-operators,-z-f(x,y)-1","page":"Operators & algebraic structures","title":"Binary operators, z = f(x,y)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"x,y,z all have the same type :\n\nz = x              z = y              z = min(x,y)       z = max (x,y)\n\nGrB_FIRST_BOOL     GrB_SECOND_BOOL    GrB_MIN_BOOL       GrB_MAX_BOOL\nGrB_FIRST_INT8     GrB_SECOND_INT8    GrB_MIN_INT8       GrB_MAX_INT8\nGrB_FIRST_UINT8    GrB_SECOND_UINT8   GrB_MIN_UINT8      GrB_MAX_UINT8\nGrB_FIRST_INT16    GrB_SECOND_INT16   GrB_MIN_INT16      GrB_MAX_INT16\nGrB_FIRST_UINT16   GrB_SECOND_UINT16  GrB_MIN_UINT16     GrB_MAX_UINT16\nGrB_FIRST_INT32    GrB_SECOND_INT32   GrB_MIN_INT32      GrB_MAX_INT32\nGrB_FIRST_UINT32   GrB_SECOND_UINT32  GrB_MIN_UINT32     GrB_MAX_UINT32\nGrB_FIRST_INT64    GrB_SECOND_INT64   GrB_MIN_INT64      GrB_MAX_INT64\nGrB_FIRST_UINT64   GrB_SECOND_UINT64  GrB_MIN_UINT64     GrB_MAX_UINT64\nGrB_FIRST_FP32     GrB_SECOND_FP32    GrB_MIN_FP32       GrB_MAX_FP32\nGrB_FIRST_FP64     GrB_SECOND_FP64    GrB_MIN_FP64       GrB_MAX_FP64\n\nz = x+y            z = x-y            z = x*y            z = x/y\n\nGrB_PLUS_BOOL      GrB_MINUS_BOOL     GrB_TIMES_BOOL     GrB_DIV_BOOL\nGrB_PLUS_INT8      GrB_MINUS_INT8     GrB_TIMES_INT8     GrB_DIV_INT8\nGrB_PLUS_UINT8     GrB_MINUS_UINT8    GrB_TIMES_UINT8    GrB_DIV_UINT8\nGrB_PLUS_INT16     GrB_MINUS_INT16    GrB_TIMES_INT16    GrB_DIV_INT16\nGrB_PLUS_UINT16    GrB_MINUS_UINT16   GrB_TIMES_UINT16   GrB_DIV_UINT16\nGrB_PLUS_INT32     GrB_MINUS_INT32    GrB_TIMES_INT32    GrB_DIV_INT32\nGrB_PLUS_UINT32    GrB_MINUS_UINT32   GrB_TIMES_UINT32   GrB_DIV_UINT32\nGrB_PLUS_INT64     GrB_MINUS_INT64    GrB_TIMES_INT64    GrB_DIV_INT64\nGrB_PLUS_UINT64    GrB_MINUS_UINT64   GrB_TIMES_UINT64   GrB_DIV_UINT64\nGrB_PLUS_FP32      GrB_MINUS_FP32     GrB_TIMES_FP32     GrB_DIV_FP32\nGrB_PLUS_FP64      GrB_MINUS_FP64     GrB_TIMES_FP64     GrB_DIV_FP64\n\nz is always boolean & x,y have the same type :\n\nz = (x == y)       z = (x != y)       z = (x > y)        z = (x < y)\n\nGrB_EQ_BOOL        GrB_NE_BOOL        GrB_GT_BOOL        GrB_LT_BOOL\nGrB_EQ_INT8        GrB_NE_INT8        GrB_GT_INT8        GrB_LT_INT8\nGrB_EQ_UINT8       GrB_NE_UINT8       GrB_GT_UINT8       GrB_LT_UINT8\nGrB_EQ_INT16       GrB_NE_INT16       GrB_GT_INT16       GrB_LT_INT16\nGrB_EQ_UINT16      GrB_NE_UINT16      GrB_GT_UINT16      GrB_LT_UINT16\nGrB_EQ_INT32       GrB_NE_INT32       GrB_GT_INT32       GrB_LT_INT32\nGrB_EQ_UINT32      GrB_NE_UINT32      GrB_GT_UINT32      GrB_LT_UINT32\nGrB_EQ_INT64       GrB_NE_INT64       GrB_GT_INT64       GrB_LT_INT64\nGrB_EQ_UINT64      GrB_NE_UINT64      GrB_GT_UINT64      GrB_LT_UINT64\nGrB_EQ_FP32        GrB_NE_FP32        GrB_GT_FP32        GrB_LT_FP32\nGrB_EQ_FP64        GrB_NE_FP64        GrB_GT_FP64        GrB_LT_FP64\n\nz = (x >= y)       z = (x <= y)\n\nGrB_GE_BOOL        GrB_LE_BOOL\nGrB_GE_INT8        GrB_LE_INT8\nGrB_GE_UINT8       GrB_LE_UINT8\nGrB_GE_INT16       GrB_LE_INT16\nGrB_GE_UINT16      GrB_LE_UINT16\nGrB_GE_INT32       GrB_LE_INT32\nGrB_GE_UINT32      GrB_LE_UINT32\nGrB_GE_INT64       GrB_LE_INT64\nGrB_GE_UINT64      GrB_LE_UINT64\nGrB_GE_FP32        GrB_LE_FP32\nGrB_GE_FP64        GrB_LE_FP64\n\nx,y,z all are boolean :\n\nz = (x || y)       z = (x && y)       z = (x != y)\n\nGrB_LOR            GrB_LAND           GrB_LXOR","category":"page"},{"location":"algebra_methods/#Monoids-1","page":"Operators & algebraic structures","title":"Monoids","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"MIN monoids:                   Identity\n\nGxB_MIN_INT8_MONOID            INT8_MAX\nGxB_MIN_UINT8_MONOID           UINT8_MAX\nGxB_MIN_INT16_MONOID           INT16_MAX\nGxB_MIN_UINT16_MONOID          UINT16_MAX\nGxB_MIN_INT32_MONOID           INT32_MAX\nGxB_MIN_UINT32_MONOID          UINT32_MAX\nGxB_MIN_INT64_MONOID           INT64_MAX\nGxB_MIN_UINT64_MONOID          UINT64_MAX\nGxB_MIN_FP32_MONOID            INFINITY\nGxB_MIN_FP64_MONOID            INFINITY\n\nMAX monoids:\n\nGxB_MAX_INT8_MONOID            INT8_MIN\nGxB_MAX_UINT8_MONOID           0\nGxB_MAX_INT16_MONOID           INT16_MIN\nGxB_MAX_UINT16_MONOID          0\nGxB_MAX_INT32_MONOID           INT32_MIN\nGxB_MAX_UINT32_MONOID          0\nGxB_MAX_INT64_MONOID           INT64_MIN\nGxB_MAX_UINT64_MONOID          0\nGxB_MAX_FP32_MONOID            -INFINITY\nGxB_MAX_FP64_MONOID            -INFINITY\n\nPLUS monoids:\n\nGxB_PLUS_INT8_MONOID           0\nGxB_PLUS_UINT8_MONOID          0\nGxB_PLUS_INT16_MONOID          0\nGxB_PLUS_UINT16_MONOID         0\nGxB_PLUS_INT32_MONOID          0\nGxB_PLUS_UINT32_MONOID         0\nGxB_PLUS_INT64_MONOID          0\nGxB_PLUS_UINT64_MONOID         0\nGxB_PLUS_FP32_MONOID           0\nGxB_PLUS_FP64_MONOID           0\n\nTIMES monoids:\n\nGxB_TIMES_INT8_MONOID          1\nGxB_TIMES_UINT8_MONOID         1\nGxB_TIMES_INT16_MONOID         1\nGxB_TIMES_UINT16_MONOID        1\nGxB_TIMES_INT32_MONOID         1\nGxB_TIMES_UINT32_MONOID        1\nGxB_TIMES_INT64_MONOID         1\nGxB_TIMES_UINT64_MONOID        1\nGxB_TIMES_FP32_MONOID          1\nGxB_TIMES_FP64_MONOID          1\n\nBoolean monoids:\n\nGxB_LOR_BOOL_MONOID            false\nGxB_LAND_BOOL_MONOID           true\nGxB_LXOR_BOOL_MONOID           false\nGxB_EQ_BOOL_MONOID             true","category":"page"},{"location":"algebra_methods/#Semirings-1","page":"Operators & algebraic structures","title":"Semirings","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"Semirings with multiply op: z = FIRST (x,y), all types x,y,z the same:\n\nGxB_MIN_FIRST_INT8      GxB_MAX_FIRST_INT8     GxB_PLUS_FIRST_INT8    GxB_TIMES_FIRST_INT8\nGxB_MIN_FIRST_UINT8     GxB_MAX_FIRST_UINT8    GxB_PLUS_FIRST_UINT8   GxB_TIMES_FIRST_UINT8\nGxB_MIN_FIRST_INT16     GxB_MAX_FIRST_INT16    GxB_PLUS_FIRST_INT16   GxB_TIMES_FIRST_INT16\nGxB_MIN_FIRST_UINT16    GxB_MAX_FIRST_UINT16   GxB_PLUS_FIRST_UINT16  GxB_TIMES_FIRST_UINT16\nGxB_MIN_FIRST_INT32     GxB_MAX_FIRST_INT32    GxB_PLUS_FIRST_INT32   GxB_TIMES_FIRST_INT32\nGxB_MIN_FIRST_UINT32    GxB_MAX_FIRST_UINT32   GxB_PLUS_FIRST_UINT32  GxB_TIMES_FIRST_UINT32\nGxB_MIN_FIRST_INT64     GxB_MAX_FIRST_INT64    GxB_PLUS_FIRST_INT64   GxB_TIMES_FIRST_INT64\nGxB_MIN_FIRST_UINT64    GxB_MAX_FIRST_UINT64   GxB_PLUS_FIRST_UINT64  GxB_TIMES_FIRST_UINT64\nGxB_MIN_FIRST_FP32      GxB_MAX_FIRST_FP32     GxB_PLUS_FIRST_FP32    GxB_TIMES_FIRST_FP32\nGxB_MIN_FIRST_FP64      GxB_MAX_FIRST_FP64     GxB_PLUS_FIRST_FP64    GxB_TIMES_FIRST_FP64\n\nSemirings with multiply op: z = SECOND (x,y), all types x,y,z the same:\n\nGxB_MIN_SECOND_INT8     GxB_MAX_SECOND_INT8    GxB_PLUS_SECOND_INT8   GxB_TIMES_SECOND_INT8\nGxB_MIN_SECOND_UINT8    GxB_MAX_SECOND_UINT8   GxB_PLUS_SECOND_UINT8  GxB_TIMES_SECOND_UINT8\nGxB_MIN_SECOND_INT16    GxB_MAX_SECOND_INT16   GxB_PLUS_SECOND_INT16  GxB_TIMES_SECOND_INT16\nGxB_MIN_SECOND_UINT16   GxB_MAX_SECOND_UINT16  GxB_PLUS_SECOND_UINT16 GxB_TIMES_SECOND_UINT16\nGxB_MIN_SECOND_INT32    GxB_MAX_SECOND_INT32   GxB_PLUS_SECOND_INT32  GxB_TIMES_SECOND_INT32\nGxB_MIN_SECOND_UINT32   GxB_MAX_SECOND_UINT32  GxB_PLUS_SECOND_UINT32 GxB_TIMES_SECOND_UINT32\nGxB_MIN_SECOND_INT64    GxB_MAX_SECOND_INT64   GxB_PLUS_SECOND_INT64  GxB_TIMES_SECOND_INT64\nGxB_MIN_SECOND_UINT64   GxB_MAX_SECOND_UINT64  GxB_PLUS_SECOND_UINT64 GxB_TIMES_SECOND_UINT64\nGxB_MIN_SECOND_FP32     GxB_MAX_SECOND_FP32    GxB_PLUS_SECOND_FP32   GxB_TIMES_SECOND_FP32\nGxB_MIN_SECOND_FP64     GxB_MAX_SECOND_FP64    GxB_PLUS_SECOND_FP64   GxB_TIMES_SECOND_FP64\n\nSemirings with multiply op: z = MIN (x,y), all types x,y,z the same:\n\nGxB_MIN_MIN_INT8        GxB_MAX_MIN_INT8       GxB_PLUS_MIN_INT8      GxB_TIMES_MIN_INT8\nGxB_MIN_MIN_UINT8       GxB_MAX_MIN_UINT8      GxB_PLUS_MIN_UINT8     GxB_TIMES_MIN_UINT8\nGxB_MIN_MIN_INT16       GxB_MAX_MIN_INT16      GxB_PLUS_MIN_INT16     GxB_TIMES_MIN_INT16\nGxB_MIN_MIN_UINT16      GxB_MAX_MIN_UINT16     GxB_PLUS_MIN_UINT16    GxB_TIMES_MIN_UINT16\nGxB_MIN_MIN_INT32       GxB_MAX_MIN_INT32      GxB_PLUS_MIN_INT32     GxB_TIMES_MIN_INT32\nGxB_MIN_MIN_UINT32      GxB_MAX_MIN_UINT32     GxB_PLUS_MIN_UINT32    GxB_TIMES_MIN_UINT32\nGxB_MIN_MIN_INT64       GxB_MAX_MIN_INT64      GxB_PLUS_MIN_INT64     GxB_TIMES_MIN_INT64\nGxB_MIN_MIN_UINT64      GxB_MAX_MIN_UINT64     GxB_PLUS_MIN_UINT64    GxB_TIMES_MIN_UINT64\nGxB_MIN_MIN_FP32        GxB_MAX_MIN_FP32       GxB_PLUS_MIN_FP32      GxB_TIMES_MIN_FP32\nGxB_MIN_MIN_FP64        GxB_MAX_MIN_FP64       GxB_PLUS_MIN_FP64      GxB_TIMES_MIN_FP64\n\nSemirings with multiply op: z = MAX (x,y), all types x,y,z the same:\n\nGxB_MIN_MAX_INT8        GxB_MAX_MAX_INT8       GxB_PLUS_MAX_INT8      GxB_TIMES_MAX_INT8\nGxB_MIN_MAX_UINT8       GxB_MAX_MAX_UINT8      GxB_PLUS_MAX_UINT8     GxB_TIMES_MAX_UINT8\nGxB_MIN_MAX_INT16       GxB_MAX_MAX_INT16      GxB_PLUS_MAX_INT16     GxB_TIMES_MAX_INT16\nGxB_MIN_MAX_UINT16      GxB_MAX_MAX_UINT16     GxB_PLUS_MAX_UINT16    GxB_TIMES_MAX_UINT16\nGxB_MIN_MAX_INT32       GxB_MAX_MAX_INT32      GxB_PLUS_MAX_INT32     GxB_TIMES_MAX_INT32\nGxB_MIN_MAX_UINT32      GxB_MAX_MAX_UINT32     GxB_PLUS_MAX_UINT32    GxB_TIMES_MAX_UINT32\nGxB_MIN_MAX_INT64       GxB_MAX_MAX_INT64      GxB_PLUS_MAX_INT64     GxB_TIMES_MAX_INT64\nGxB_MIN_MAX_UINT64      GxB_MAX_MAX_UINT64     GxB_PLUS_MAX_UINT64    GxB_TIMES_MAX_UINT64\nGxB_MIN_MAX_FP32        GxB_MAX_MAX_FP32       GxB_PLUS_MAX_FP32      GxB_TIMES_MAX_FP32\nGxB_MIN_MAX_FP64        GxB_MAX_MAX_FP64       GxB_PLUS_MAX_FP64      GxB_TIMES_MAX_FP64\n\nSemirings with multiply op: z = PLUS (x,y), all types x,y,z the same:\n\nGxB_MIN_PLUS_INT8       GxB_MAX_PLUS_INT8      GxB_PLUS_PLUS_INT8     GxB_TIMES_PLUS_INT8\nGxB_MIN_PLUS_UINT8      GxB_MAX_PLUS_UINT8     GxB_PLUS_PLUS_UINT8    GxB_TIMES_PLUS_UINT8\nGxB_MIN_PLUS_INT16      GxB_MAX_PLUS_INT16     GxB_PLUS_PLUS_INT16    GxB_TIMES_PLUS_INT16\nGxB_MIN_PLUS_UINT16     GxB_MAX_PLUS_UINT16    GxB_PLUS_PLUS_UINT16   GxB_TIMES_PLUS_UINT16\nGxB_MIN_PLUS_INT32      GxB_MAX_PLUS_INT32     GxB_PLUS_PLUS_INT32    GxB_TIMES_PLUS_INT32\nGxB_MIN_PLUS_UINT32     GxB_MAX_PLUS_UINT32    GxB_PLUS_PLUS_UINT32   GxB_TIMES_PLUS_UINT32\nGxB_MIN_PLUS_INT64      GxB_MAX_PLUS_INT64     GxB_PLUS_PLUS_INT64    GxB_TIMES_PLUS_INT64\nGxB_MIN_PLUS_UINT64     GxB_MAX_PLUS_UINT64    GxB_PLUS_PLUS_UINT64   GxB_TIMES_PLUS_UINT64\nGxB_MIN_PLUS_FP32       GxB_MAX_PLUS_FP32      GxB_PLUS_PLUS_FP32     GxB_TIMES_PLUS_FP32\nGxB_MIN_PLUS_FP64       GxB_MAX_PLUS_FP64      GxB_PLUS_PLUS_FP64     GxB_TIMES_PLUS_FP64\n\nSemirings with multiply op: z = MINUS (x,y), all types x,y,z the same:\n\nGxB_MIN_MINUS_INT8     GxB_MAX_MINUS_INT8     GxB_PLUS_MINUS_INT8    GxB_TIMES_MINUS_INT8\nGxB_MIN_MINUS_UINT8    GxB_MAX_MINUS_UINT8    GxB_PLUS_MINUS_UINT8   GxB_TIMES_MINUS_UINT8\nGxB_MIN_MINUS_INT16    GxB_MAX_MINUS_INT16    GxB_PLUS_MINUS_INT16   GxB_TIMES_MINUS_INT16\nGxB_MIN_MINUS_UINT16   GxB_MAX_MINUS_UINT16   GxB_PLUS_MINUS_UINT16  GxB_TIMES_MINUS_UINT16\nGxB_MIN_MINUS_INT32    GxB_MAX_MINUS_INT32    GxB_PLUS_MINUS_INT32   GxB_TIMES_MINUS_INT32\nGxB_MIN_MINUS_UINT32   GxB_MAX_MINUS_UINT32   GxB_PLUS_MINUS_UINT32  GxB_TIMES_MINUS_UINT32\nGxB_MIN_MINUS_INT64    GxB_MAX_MINUS_INT64    GxB_PLUS_MINUS_INT64   GxB_TIMES_MINUS_INT64\nGxB_MIN_MINUS_UINT64   GxB_MAX_MINUS_UINT64   GxB_PLUS_MINUS_UINT64  GxB_TIMES_MINUS_UINT64\nGxB_MIN_MINUS_FP32     GxB_MAX_MINUS_FP32     GxB_PLUS_MINUS_FP32    GxB_TIMES_MINUS_FP32\nGxB_MIN_MINUS_FP64     GxB_MAX_MINUS_FP64     GxB_PLUS_MINUS_FP64    GxB_TIMES_MINUS_FP64\n\nSemirings with multiply op: z = TIMES (x,y), all types x,y,z the same:\n\nGxB_MIN_TIMES_INT8     GxB_MAX_TIMES_INT8     GxB_PLUS_TIMES_INT8    GxB_TIMES_TIMES_INT8\nGxB_MIN_TIMES_UINT8    GxB_MAX_TIMES_UINT8    GxB_PLUS_TIMES_UINT8   GxB_TIMES_TIMES_UINT8\nGxB_MIN_TIMES_INT16    GxB_MAX_TIMES_INT16    GxB_PLUS_TIMES_INT16   GxB_TIMES_TIMES_INT16\nGxB_MIN_TIMES_UINT16   GxB_MAX_TIMES_UINT16   GxB_PLUS_TIMES_UINT16  GxB_TIMES_TIMES_UINT16\nGxB_MIN_TIMES_INT32    GxB_MAX_TIMES_INT32    GxB_PLUS_TIMES_INT32   GxB_TIMES_TIMES_INT32\nGxB_MIN_TIMES_UINT32   GxB_MAX_TIMES_UINT32   GxB_PLUS_TIMES_UINT32  GxB_TIMES_TIMES_UINT32\nGxB_MIN_TIMES_INT64    GxB_MAX_TIMES_INT64    GxB_PLUS_TIMES_INT64   GxB_TIMES_TIMES_INT64\nGxB_MIN_TIMES_UINT64   GxB_MAX_TIMES_UINT64   GxB_PLUS_TIMES_UINT64  GxB_TIMES_TIMES_UINT64\nGxB_MIN_TIMES_FP32     GxB_MAX_TIMES_FP32     GxB_PLUS_TIMES_FP32    GxB_TIMES_TIMES_FP32\nGxB_MIN_TIMES_FP64     GxB_MAX_TIMES_FP64     GxB_PLUS_TIMES_FP64    GxB_TIMES_TIMES_FP64\n\nSemirings with multiply op: z = DIV (x,y), all types x,y,z the same:\n\nGxB_MIN_DIV_INT8       GxB_MAX_DIV_INT8       GxB_PLUS_DIV_INT8      GxB_TIMES_DIV_INT8\nGxB_MIN_DIV_UINT8      GxB_MAX_DIV_UINT8      GxB_PLUS_DIV_UINT8     GxB_TIMES_DIV_UINT8\nGxB_MIN_DIV_INT16      GxB_MAX_DIV_INT16      GxB_PLUS_DIV_INT16     GxB_TIMES_DIV_INT16\nGxB_MIN_DIV_UINT16     GxB_MAX_DIV_UINT16     GxB_PLUS_DIV_UINT16    GxB_TIMES_DIV_UINT16\nGxB_MIN_DIV_INT32      GxB_MAX_DIV_INT32      GxB_PLUS_DIV_INT32     GxB_TIMES_DIV_INT32\nGxB_MIN_DIV_UINT32     GxB_MAX_DIV_UINT32     GxB_PLUS_DIV_UINT32    GxB_TIMES_DIV_UINT32\nGxB_MIN_DIV_INT64      GxB_MAX_DIV_INT64      GxB_PLUS_DIV_INT64     GxB_TIMES_DIV_INT64\nGxB_MIN_DIV_UINT64     GxB_MAX_DIV_UINT64     GxB_PLUS_DIV_UINT64    GxB_TIMES_DIV_UINT64\nGxB_MIN_DIV_FP32       GxB_MAX_DIV_FP32       GxB_PLUS_DIV_FP32      GxB_TIMES_DIV_FP32\nGxB_MIN_DIV_FP64       GxB_MAX_DIV_FP64       GxB_PLUS_DIV_FP64      GxB_TIMES_DIV_FP64\n\nSemirings with multiply op: z = ISEQ (x,y), all types x,y,z the same:\n\nGxB_MIN_ISEQ_INT8      GxB_MAX_ISEQ_INT8      GxB_PLUS_ISEQ_INT8     GxB_TIMES_ISEQ_INT8\nGxB_MIN_ISEQ_UINT8     GxB_MAX_ISEQ_UINT8     GxB_PLUS_ISEQ_UINT8    GxB_TIMES_ISEQ_UINT8\nGxB_MIN_ISEQ_INT16     GxB_MAX_ISEQ_INT16     GxB_PLUS_ISEQ_INT16    GxB_TIMES_ISEQ_INT16\nGxB_MIN_ISEQ_UINT16    GxB_MAX_ISEQ_UINT16    GxB_PLUS_ISEQ_UINT16   GxB_TIMES_ISEQ_UINT16\nGxB_MIN_ISEQ_INT32     GxB_MAX_ISEQ_INT32     GxB_PLUS_ISEQ_INT32    GxB_TIMES_ISEQ_INT32\nGxB_MIN_ISEQ_UINT32    GxB_MAX_ISEQ_UINT32    GxB_PLUS_ISEQ_UINT32   GxB_TIMES_ISEQ_UINT32\nGxB_MIN_ISEQ_INT64     GxB_MAX_ISEQ_INT64     GxB_PLUS_ISEQ_INT64    GxB_TIMES_ISEQ_INT64\nGxB_MIN_ISEQ_UINT64    GxB_MAX_ISEQ_UINT64    GxB_PLUS_ISEQ_UINT64   GxB_TIMES_ISEQ_UINT64\nGxB_MIN_ISEQ_FP32      GxB_MAX_ISEQ_FP32      GxB_PLUS_ISEQ_FP32     GxB_TIMES_ISEQ_FP32\nGxB_MIN_ISEQ_FP64      GxB_MAX_ISEQ_FP64      GxB_PLUS_ISEQ_FP64     GxB_TIMES_ISEQ_FP64\n\nSemirings with multiply op: z = ISNE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISNE_INT8      GxB_MAX_ISNE_INT8      GxB_PLUS_ISNE_INT8     GxB_TIMES_ISNE_INT8\nGxB_MIN_ISNE_UINT8     GxB_MAX_ISNE_UINT8     GxB_PLUS_ISNE_UINT8    GxB_TIMES_ISNE_UINT8\nGxB_MIN_ISNE_INT16     GxB_MAX_ISNE_INT16     GxB_PLUS_ISNE_INT16    GxB_TIMES_ISNE_INT16\nGxB_MIN_ISNE_UINT16    GxB_MAX_ISNE_UINT16    GxB_PLUS_ISNE_UINT16   GxB_TIMES_ISNE_UINT16\nGxB_MIN_ISNE_INT32     GxB_MAX_ISNE_INT32     GxB_PLUS_ISNE_INT32    GxB_TIMES_ISNE_INT32\nGxB_MIN_ISNE_UINT32    GxB_MAX_ISNE_UINT32    GxB_PLUS_ISNE_UINT32   GxB_TIMES_ISNE_UINT32\nGxB_MIN_ISNE_INT64     GxB_MAX_ISNE_INT64     GxB_PLUS_ISNE_INT64    GxB_TIMES_ISNE_INT64\nGxB_MIN_ISNE_UINT64    GxB_MAX_ISNE_UINT64    GxB_PLUS_ISNE_UINT64   GxB_TIMES_ISNE_UINT64\nGxB_MIN_ISNE_FP32      GxB_MAX_ISNE_FP32      GxB_PLUS_ISNE_FP32     GxB_TIMES_ISNE_FP32\nGxB_MIN_ISNE_FP64      GxB_MAX_ISNE_FP64      GxB_PLUS_ISNE_FP64     GxB_TIMES_ISNE_FP64\n\nSemirings with multiply op: z = ISGT (x,y), all types x,y,z the same:\n\nGxB_MIN_ISGT_INT8      GxB_MAX_ISGT_INT8      GxB_PLUS_ISGT_INT8     GxB_TIMES_ISGT_INT8\nGxB_MIN_ISGT_UINT8     GxB_MAX_ISGT_UINT8     GxB_PLUS_ISGT_UINT8    GxB_TIMES_ISGT_UINT8\nGxB_MIN_ISGT_INT16     GxB_MAX_ISGT_INT16     GxB_PLUS_ISGT_INT16    GxB_TIMES_ISGT_INT16\nGxB_MIN_ISGT_UINT16    GxB_MAX_ISGT_UINT16    GxB_PLUS_ISGT_UINT16   GxB_TIMES_ISGT_UINT16\nGxB_MIN_ISGT_INT32     GxB_MAX_ISGT_INT32     GxB_PLUS_ISGT_INT32    GxB_TIMES_ISGT_INT32\nGxB_MIN_ISGT_UINT32    GxB_MAX_ISGT_UINT32    GxB_PLUS_ISGT_UINT32   GxB_TIMES_ISGT_UINT32\nGxB_MIN_ISGT_INT64     GxB_MAX_ISGT_INT64     GxB_PLUS_ISGT_INT64    GxB_TIMES_ISGT_INT64\nGxB_MIN_ISGT_UINT64    GxB_MAX_ISGT_UINT64    GxB_PLUS_ISGT_UINT64   GxB_TIMES_ISGT_UINT64\nGxB_MIN_ISGT_FP32      GxB_MAX_ISGT_FP32      GxB_PLUS_ISGT_FP32     GxB_TIMES_ISGT_FP32\nGxB_MIN_ISGT_FP64      GxB_MAX_ISGT_FP64      GxB_PLUS_ISGT_FP64     GxB_TIMES_ISGT_FP64\n\nSemirings with multiply op: z = ISLT (x,y), all types x,y,z the same:\n\nGxB_MIN_ISLT_INT8      GxB_MAX_ISLT_INT8      GxB_PLUS_ISLT_INT8     GxB_TIMES_ISLT_INT8\nGxB_MIN_ISLT_UINT8     GxB_MAX_ISLT_UINT8     GxB_PLUS_ISLT_UINT8    GxB_TIMES_ISLT_UINT8\nGxB_MIN_ISLT_INT16     GxB_MAX_ISLT_INT16     GxB_PLUS_ISLT_INT16    GxB_TIMES_ISLT_INT16\nGxB_MIN_ISLT_UINT16    GxB_MAX_ISLT_UINT16    GxB_PLUS_ISLT_UINT16   GxB_TIMES_ISLT_UINT16\nGxB_MIN_ISLT_INT32     GxB_MAX_ISLT_INT32     GxB_PLUS_ISLT_INT32    GxB_TIMES_ISLT_INT32\nGxB_MIN_ISLT_UINT32    GxB_MAX_ISLT_UINT32    GxB_PLUS_ISLT_UINT32   GxB_TIMES_ISLT_UINT32\nGxB_MIN_ISLT_INT64     GxB_MAX_ISLT_INT64     GxB_PLUS_ISLT_INT64    GxB_TIMES_ISLT_INT64\nGxB_MIN_ISLT_UINT64    GxB_MAX_ISLT_UINT64    GxB_PLUS_ISLT_UINT64   GxB_TIMES_ISLT_UINT64\nGxB_MIN_ISLT_FP32      GxB_MAX_ISLT_FP32      GxB_PLUS_ISLT_FP32     GxB_TIMES_ISLT_FP32\nGxB_MIN_ISLT_FP64      GxB_MAX_ISLT_FP64      GxB_PLUS_ISLT_FP64     GxB_TIMES_ISLT_FP64\n\nSemirings with multiply op: z = ISGE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISGE_INT8      GxB_MAX_ISGE_INT8      GxB_PLUS_ISGE_INT8     GxB_TIMES_ISGE_INT8\nGxB_MIN_ISGE_UINT8     GxB_MAX_ISGE_UINT8     GxB_PLUS_ISGE_UINT8    GxB_TIMES_ISGE_UINT8\nGxB_MIN_ISGE_INT16     GxB_MAX_ISGE_INT16     GxB_PLUS_ISGE_INT16    GxB_TIMES_ISGE_INT16\nGxB_MIN_ISGE_UINT16    GxB_MAX_ISGE_UINT16    GxB_PLUS_ISGE_UINT16   GxB_TIMES_ISGE_UINT16\nGxB_MIN_ISGE_INT32     GxB_MAX_ISGE_INT32     GxB_PLUS_ISGE_INT32    GxB_TIMES_ISGE_INT32\nGxB_MIN_ISGE_UINT32    GxB_MAX_ISGE_UINT32    GxB_PLUS_ISGE_UINT32   GxB_TIMES_ISGE_UINT32\nGxB_MIN_ISGE_INT64     GxB_MAX_ISGE_INT64     GxB_PLUS_ISGE_INT64    GxB_TIMES_ISGE_INT64\nGxB_MIN_ISGE_UINT64    GxB_MAX_ISGE_UINT64    GxB_PLUS_ISGE_UINT64   GxB_TIMES_ISGE_UINT64\nGxB_MIN_ISGE_FP32      GxB_MAX_ISGE_FP32      GxB_PLUS_ISGE_FP32     GxB_TIMES_ISGE_FP32\nGxB_MIN_ISGE_FP64      GxB_MAX_ISGE_FP64      GxB_PLUS_ISGE_FP64     GxB_TIMES_ISGE_FP64\n\nSemirings with multiply op: z = ISLE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISLE_INT8      GxB_MAX_ISLE_INT8      GxB_PLUS_ISLE_INT8     GxB_TIMES_ISLE_INT8\nGxB_MIN_ISLE_UINT8     GxB_MAX_ISLE_UINT8     GxB_PLUS_ISLE_UINT8    GxB_TIMES_ISLE_UINT8\nGxB_MIN_ISLE_INT16     GxB_MAX_ISLE_INT16     GxB_PLUS_ISLE_INT16    GxB_TIMES_ISLE_INT16\nGxB_MIN_ISLE_UINT16    GxB_MAX_ISLE_UINT16    GxB_PLUS_ISLE_UINT16   GxB_TIMES_ISLE_UINT16\nGxB_MIN_ISLE_INT32     GxB_MAX_ISLE_INT32     GxB_PLUS_ISLE_INT32    GxB_TIMES_ISLE_INT32\nGxB_MIN_ISLE_UINT32    GxB_MAX_ISLE_UINT32    GxB_PLUS_ISLE_UINT32   GxB_TIMES_ISLE_UINT32\nGxB_MIN_ISLE_INT64     GxB_MAX_ISLE_INT64     GxB_PLUS_ISLE_INT64    GxB_TIMES_ISLE_INT64\nGxB_MIN_ISLE_UINT64    GxB_MAX_ISLE_UINT64    GxB_PLUS_ISLE_UINT64   GxB_TIMES_ISLE_UINT64\nGxB_MIN_ISLE_FP32      GxB_MAX_ISLE_FP32      GxB_PLUS_ISLE_FP32     GxB_TIMES_ISLE_FP32\nGxB_MIN_ISLE_FP64      GxB_MAX_ISLE_FP64      GxB_PLUS_ISLE_FP64     GxB_TIMES_ISLE_FP64\n\nSemirings with multiply op: z = LOR (x,y), all types x,y,z the same:\n\nGxB_MIN_LOR_INT8       GxB_MAX_LOR_INT8       GxB_PLUS_LOR_INT8      GxB_TIMES_LOR_INT8\nGxB_MIN_LOR_UINT8      GxB_MAX_LOR_UINT8      GxB_PLUS_LOR_UINT8     GxB_TIMES_LOR_UINT8\nGxB_MIN_LOR_INT16      GxB_MAX_LOR_INT16      GxB_PLUS_LOR_INT16     GxB_TIMES_LOR_INT16\nGxB_MIN_LOR_UINT16     GxB_MAX_LOR_UINT16     GxB_PLUS_LOR_UINT16    GxB_TIMES_LOR_UINT16\nGxB_MIN_LOR_INT32      GxB_MAX_LOR_INT32      GxB_PLUS_LOR_INT32     GxB_TIMES_LOR_INT32\nGxB_MIN_LOR_UINT32     GxB_MAX_LOR_UINT32     GxB_PLUS_LOR_UINT32    GxB_TIMES_LOR_UINT32\nGxB_MIN_LOR_INT64      GxB_MAX_LOR_INT64      GxB_PLUS_LOR_INT64     GxB_TIMES_LOR_INT64\nGxB_MIN_LOR_UINT64     GxB_MAX_LOR_UINT64     GxB_PLUS_LOR_UINT64    GxB_TIMES_LOR_UINT64\nGxB_MIN_LOR_FP32       GxB_MAX_LOR_FP32       GxB_PLUS_LOR_FP32      GxB_TIMES_LOR_FP32\nGxB_MIN_LOR_FP64       GxB_MAX_LOR_FP64       GxB_PLUS_LOR_FP64      GxB_TIMES_LOR_FP64\n\nSemirings with multiply op: z = LAND (x,y), all types x,y,z the same:\n\nGxB_MIN_LAND_INT8      GxB_MAX_LAND_INT8      GxB_PLUS_LAND_INT8     GxB_TIMES_LAND_INT8\nGxB_MIN_LAND_UINT8     GxB_MAX_LAND_UINT8     GxB_PLUS_LAND_UINT8    GxB_TIMES_LAND_UINT8\nGxB_MIN_LAND_INT16     GxB_MAX_LAND_INT16     GxB_PLUS_LAND_INT16    GxB_TIMES_LAND_INT16\nGxB_MIN_LAND_UINT16    GxB_MAX_LAND_UINT16    GxB_PLUS_LAND_UINT16   GxB_TIMES_LAND_UINT16\nGxB_MIN_LAND_INT32     GxB_MAX_LAND_INT32     GxB_PLUS_LAND_INT32    GxB_TIMES_LAND_INT32\nGxB_MIN_LAND_UINT32    GxB_MAX_LAND_UINT32    GxB_PLUS_LAND_UINT32   GxB_TIMES_LAND_UINT32\nGxB_MIN_LAND_INT64     GxB_MAX_LAND_INT64     GxB_PLUS_LAND_INT64    GxB_TIMES_LAND_INT64\nGxB_MIN_LAND_UINT64    GxB_MAX_LAND_UINT64    GxB_PLUS_LAND_UINT64   GxB_TIMES_LAND_UINT64\nGxB_MIN_LAND_FP32      GxB_MAX_LAND_FP32      GxB_PLUS_LAND_FP32     GxB_TIMES_LAND_FP32\nGxB_MIN_LAND_FP64      GxB_MAX_LAND_FP64      GxB_PLUS_LAND_FP64     GxB_TIMES_LAND_FP64\n\nSemirings with multiply op: z = LXOR (x,y), all types x,y,z the same:\n\nGxB_MIN_LXOR_INT8      GxB_MAX_LXOR_INT8      GxB_PLUS_LXOR_INT8     GxB_TIMES_LXOR_INT8\nGxB_MIN_LXOR_UINT8     GxB_MAX_LXOR_UINT8     GxB_PLUS_LXOR_UINT8    GxB_TIMES_LXOR_UINT8\nGxB_MIN_LXOR_INT16     GxB_MAX_LXOR_INT16     GxB_PLUS_LXOR_INT16    GxB_TIMES_LXOR_INT16\nGxB_MIN_LXOR_UINT16    GxB_MAX_LXOR_UINT16    GxB_PLUS_LXOR_UINT16   GxB_TIMES_LXOR_UINT16\nGxB_MIN_LXOR_INT32     GxB_MAX_LXOR_INT32     GxB_PLUS_LXOR_INT32    GxB_TIMES_LXOR_INT32\nGxB_MIN_LXOR_UINT32    GxB_MAX_LXOR_UINT32    GxB_PLUS_LXOR_UINT32   GxB_TIMES_LXOR_UINT32\nGxB_MIN_LXOR_INT64     GxB_MAX_LXOR_INT64     GxB_PLUS_LXOR_INT64    GxB_TIMES_LXOR_INT64\nGxB_MIN_LXOR_UINT64    GxB_MAX_LXOR_UINT64    GxB_PLUS_LXOR_UINT64   GxB_TIMES_LXOR_UINT64\nGxB_MIN_LXOR_FP32      GxB_MAX_LXOR_FP32      GxB_PLUS_LXOR_FP32     GxB_TIMES_LXOR_FP32\nGxB_MIN_LXOR_FP64      GxB_MAX_LXOR_FP64      GxB_PLUS_LXOR_FP64     GxB_TIMES_LXOR_FP64\n\nSemirings with multiply op: z = EQ (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_EQ_INT8        GxB_LAND_EQ_INT8       GxB_LXOR_EQ_INT8       GxB_EQ_EQ_INT8\nGxB_LOR_EQ_UINT8       GxB_LAND_EQ_UINT8      GxB_LXOR_EQ_UINT8      GxB_EQ_EQ_UINT8\nGxB_LOR_EQ_INT16       GxB_LAND_EQ_INT16      GxB_LXOR_EQ_INT16      GxB_EQ_EQ_INT16\nGxB_LOR_EQ_UINT16      GxB_LAND_EQ_UINT16     GxB_LXOR_EQ_UINT16     GxB_EQ_EQ_UINT16\nGxB_LOR_EQ_INT32       GxB_LAND_EQ_INT32      GxB_LXOR_EQ_INT32      GxB_EQ_EQ_INT32\nGxB_LOR_EQ_UINT32      GxB_LAND_EQ_UINT32     GxB_LXOR_EQ_UINT32     GxB_EQ_EQ_UINT32\nGxB_LOR_EQ_INT64       GxB_LAND_EQ_INT64      GxB_LXOR_EQ_INT64      GxB_EQ_EQ_INT64\nGxB_LOR_EQ_UINT64      GxB_LAND_EQ_UINT64     GxB_LXOR_EQ_UINT64     GxB_EQ_EQ_UINT64\nGxB_LOR_EQ_FP32        GxB_LAND_EQ_FP32       GxB_LXOR_EQ_FP32       GxB_EQ_EQ_FP32\nGxB_LOR_EQ_FP64        GxB_LAND_EQ_FP64       GxB_LXOR_EQ_FP64       GxB_EQ_EQ_FP64\n\nSemirings with multiply op: z = NE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_NE_INT8        GxB_LAND_NE_INT8       GxB_LXOR_NE_INT8       GxB_EQ_NE_INT8\nGxB_LOR_NE_UINT8       GxB_LAND_NE_UINT8      GxB_LXOR_NE_UINT8      GxB_EQ_NE_UINT8\nGxB_LOR_NE_INT16       GxB_LAND_NE_INT16      GxB_LXOR_NE_INT16      GxB_EQ_NE_INT16\nGxB_LOR_NE_UINT16      GxB_LAND_NE_UINT16     GxB_LXOR_NE_UINT16     GxB_EQ_NE_UINT16\nGxB_LOR_NE_INT32       GxB_LAND_NE_INT32      GxB_LXOR_NE_INT32      GxB_EQ_NE_INT32\nGxB_LOR_NE_UINT32      GxB_LAND_NE_UINT32     GxB_LXOR_NE_UINT32     GxB_EQ_NE_UINT32\nGxB_LOR_NE_INT64       GxB_LAND_NE_INT64      GxB_LXOR_NE_INT64      GxB_EQ_NE_INT64\nGxB_LOR_NE_UINT64      GxB_LAND_NE_UINT64     GxB_LXOR_NE_UINT64     GxB_EQ_NE_UINT64\nGxB_LOR_NE_FP32        GxB_LAND_NE_FP32       GxB_LXOR_NE_FP32       GxB_EQ_NE_FP32\nGxB_LOR_NE_FP64        GxB_LAND_NE_FP64       GxB_LXOR_NE_FP64       GxB_EQ_NE_FP64\n\nSemirings with multiply op: z = GT (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_GT_INT8        GxB_LAND_GT_INT8       GxB_LXOR_GT_INT8       GxB_EQ_GT_INT8\nGxB_LOR_GT_UINT8       GxB_LAND_GT_UINT8      GxB_LXOR_GT_UINT8      GxB_EQ_GT_UINT8\nGxB_LOR_GT_INT16       GxB_LAND_GT_INT16      GxB_LXOR_GT_INT16      GxB_EQ_GT_INT16\nGxB_LOR_GT_UINT16      GxB_LAND_GT_UINT16     GxB_LXOR_GT_UINT16     GxB_EQ_GT_UINT16\nGxB_LOR_GT_INT32       GxB_LAND_GT_INT32      GxB_LXOR_GT_INT32      GxB_EQ_GT_INT32\nGxB_LOR_GT_UINT32      GxB_LAND_GT_UINT32     GxB_LXOR_GT_UINT32     GxB_EQ_GT_UINT32\nGxB_LOR_GT_INT64       GxB_LAND_GT_INT64      GxB_LXOR_GT_INT64      GxB_EQ_GT_INT64\nGxB_LOR_GT_UINT64      GxB_LAND_GT_UINT64     GxB_LXOR_GT_UINT64     GxB_EQ_GT_UINT64\nGxB_LOR_GT_FP32        GxB_LAND_GT_FP32       GxB_LXOR_GT_FP32       GxB_EQ_GT_FP32\nGxB_LOR_GT_FP64        GxB_LAND_GT_FP64       GxB_LXOR_GT_FP64       GxB_EQ_GT_FP64\n\nSemirings with multiply op: z = LT (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_LT_INT8        GxB_LAND_LT_INT8       GxB_LXOR_LT_INT8       GxB_EQ_LT_INT8\nGxB_LOR_LT_UINT8       GxB_LAND_LT_UINT8      GxB_LXOR_LT_UINT8      GxB_EQ_LT_UINT8\nGxB_LOR_LT_INT16       GxB_LAND_LT_INT16      GxB_LXOR_LT_INT16      GxB_EQ_LT_INT16\nGxB_LOR_LT_UINT16      GxB_LAND_LT_UINT16     GxB_LXOR_LT_UINT16     GxB_EQ_LT_UINT16\nGxB_LOR_LT_INT32       GxB_LAND_LT_INT32      GxB_LXOR_LT_INT32      GxB_EQ_LT_INT32\nGxB_LOR_LT_UINT32      GxB_LAND_LT_UINT32     GxB_LXOR_LT_UINT32     GxB_EQ_LT_UINT32\nGxB_LOR_LT_INT64       GxB_LAND_LT_INT64      GxB_LXOR_LT_INT64      GxB_EQ_LT_INT64\nGxB_LOR_LT_UINT64      GxB_LAND_LT_UINT64     GxB_LXOR_LT_UINT64     GxB_EQ_LT_UINT64\nGxB_LOR_LT_FP32        GxB_LAND_LT_FP32       GxB_LXOR_LT_FP32       GxB_EQ_LT_FP32\nGxB_LOR_LT_FP64        GxB_LAND_LT_FP64       GxB_LXOR_LT_FP64       GxB_EQ_LT_FP64\n\nSemirings with multiply op: z = GE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_GE_INT8        GxB_LAND_GE_INT8       GxB_LXOR_GE_INT8       GxB_EQ_GE_INT8\nGxB_LOR_GE_UINT8       GxB_LAND_GE_UINT8      GxB_LXOR_GE_UINT8      GxB_EQ_GE_UINT8\nGxB_LOR_GE_INT16       GxB_LAND_GE_INT16      GxB_LXOR_GE_INT16      GxB_EQ_GE_INT16\nGxB_LOR_GE_UINT16      GxB_LAND_GE_UINT16     GxB_LXOR_GE_UINT16     GxB_EQ_GE_UINT16\nGxB_LOR_GE_INT32       GxB_LAND_GE_INT32      GxB_LXOR_GE_INT32      GxB_EQ_GE_INT32\nGxB_LOR_GE_UINT32      GxB_LAND_GE_UINT32     GxB_LXOR_GE_UINT32     GxB_EQ_GE_UINT32\nGxB_LOR_GE_INT64       GxB_LAND_GE_INT64      GxB_LXOR_GE_INT64      GxB_EQ_GE_INT64\nGxB_LOR_GE_UINT64      GxB_LAND_GE_UINT64     GxB_LXOR_GE_UINT64     GxB_EQ_GE_UINT64\nGxB_LOR_GE_FP32        GxB_LAND_GE_FP32       GxB_LXOR_GE_FP32       GxB_EQ_GE_FP32\nGxB_LOR_GE_FP64        GxB_LAND_GE_FP64       GxB_LXOR_GE_FP64       GxB_EQ_GE_FP64\n\nSemirings with multiply op: z = LE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_LE_INT8        GxB_LAND_LE_INT8       GxB_LXOR_LE_INT8       GxB_EQ_LE_INT8\nGxB_LOR_LE_UINT8       GxB_LAND_LE_UINT8      GxB_LXOR_LE_UINT8      GxB_EQ_LE_UINT8\nGxB_LOR_LE_INT16       GxB_LAND_LE_INT16      GxB_LXOR_LE_INT16      GxB_EQ_LE_INT16\nGxB_LOR_LE_UINT16      GxB_LAND_LE_UINT16     GxB_LXOR_LE_UINT16     GxB_EQ_LE_UINT16\nGxB_LOR_LE_INT32       GxB_LAND_LE_INT32      GxB_LXOR_LE_INT32      GxB_EQ_LE_INT32\nGxB_LOR_LE_UINT32      GxB_LAND_LE_UINT32     GxB_LXOR_LE_UINT32     GxB_EQ_LE_UINT32\nGxB_LOR_LE_INT64       GxB_LAND_LE_INT64      GxB_LXOR_LE_INT64      GxB_EQ_LE_INT64\nGxB_LOR_LE_UINT64      GxB_LAND_LE_UINT64     GxB_LXOR_LE_UINT64     GxB_EQ_LE_UINT64\nGxB_LOR_LE_FP32        GxB_LAND_LE_FP32       GxB_LXOR_LE_FP32       GxB_EQ_LE_FP32\nGxB_LOR_LE_FP64        GxB_LAND_LE_FP64       GxB_LXOR_LE_FP64       GxB_EQ_LE_FP64\n\nPurely boolean semirings (in the form GxB_(add monoid)_(multipy operator)_BOOL:\n\nGxB_LOR_FIRST_BOOL     GxB_LAND_FIRST_BOOL    GxB_LXOR_FIRST_BOOL    GxB_EQ_FIRST_BOOL\nGxB_LOR_SECOND_BOOL    GxB_LAND_SECOND_BOOL   GxB_LXOR_SECOND_BOOL   GxB_EQ_SECOND_BOOL\nGxB_LOR_LOR_BOOL       GxB_LAND_LOR_BOOL      GxB_LXOR_LOR_BOOL      GxB_EQ_LOR_BOOL\nGxB_LOR_LAND_BOOL      GxB_LAND_LAND_BOOL     GxB_LXOR_LAND_BOOL     GxB_EQ_LAND_BOOL\nGxB_LOR_LXOR_BOOL      GxB_LAND_LXOR_BOOL     GxB_LXOR_LXOR_BOOL     GxB_EQ_LXOR_BOOL\nGxB_LOR_EQ_BOOL        GxB_LAND_EQ_BOOL       GxB_LXOR_EQ_BOOL       GxB_EQ_EQ_BOOL\nGxB_LOR_GT_BOOL        GxB_LAND_GT_BOOL       GxB_LXOR_GT_BOOL       GxB_EQ_GT_BOOL\nGxB_LOR_LT_BOOL        GxB_LAND_LT_BOOL       GxB_LXOR_LT_BOOL       GxB_EQ_LT_BOOL\nGxB_LOR_GE_BOOL        GxB_LAND_GE_BOOL       GxB_LXOR_GE_BOOL       GxB_EQ_GE_BOOL\nGxB_LOR_LE_BOOL        GxB_LAND_LE_BOOL       GxB_LXOR_LE_BOOL       GxB_EQ_LE_BOOL","category":"page"},{"location":"desc_methods/#Descriptor-methods-1","page":"Descriptors","title":"Descriptor methods","text":"","category":"section"},{"location":"desc_methods/#","page":"Descriptors","title":"Descriptors","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\n    \"Object_Methods/Descriptor_Methods.jl\",\n]\nPrivate = false","category":"page"},{"location":"desc_methods/#SuiteSparseGraphBLAS.GrB_Descriptor_new-Tuple{GrB_Descriptor}","page":"Descriptors","title":"SuiteSparseGraphBLAS.GrB_Descriptor_new","text":"GrB_Descriptor_new(desc)\n\nCreate a new (empty or default) descriptor.\n\n\n\n\n\n","category":"method"},{"location":"desc_methods/#SuiteSparseGraphBLAS.GrB_Descriptor_set-Tuple{GrB_Descriptor,GrB_Desc_Field,GrB_Desc_Value}","page":"Descriptors","title":"SuiteSparseGraphBLAS.GrB_Descriptor_set","text":"GrB_Descriptor_set(desc, field, val)\n\nSet the content for a field for an existing descriptor.\n\n\n\n\n\n","category":"method"},{"location":"free_methods/#Free-methods-1","page":"Freeing objects","title":"Free methods","text":"","category":"section"},{"location":"free_methods/#","page":"Freeing objects","title":"Freeing objects","text":"GrB_free\nGrB_UnaryOp_free\nGrB_BinaryOp_free\nGrB_Monoid_free\nGrB_Semiring_free\nGrB_Matrix_free\nGrB_Vector_free\nGrB_Descriptor_free","category":"page"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_free","text":"GrB_free(object)\n\nGeneric method to free a GraphBLAS object.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> I = [0, 2, 4]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Vector_new(w, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(w, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: int64 10\n    row 2: int64 20\n    row 4: int64 30\n\n\njulia> GrB_free(w)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w NULL\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_UnaryOp_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_UnaryOp_free","text":"GrB_UnaryOp_free(unaryop)\n\nFree unary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_BinaryOp_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_BinaryOp_free","text":"GrB_BinaryOp_free(binaryop)\n\nFree binary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_Monoid_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_Monoid_free","text":"GrB_Monoid_free(monoid)\n\nFree monoid.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_Semiring_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_Semiring_free","text":"GrB_Semiring_free(semiring)\n\nFree semiring.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_Matrix_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_Matrix_free","text":"GrB_Matrix_free(A)\n\nFree matrix.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_Vector_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_Vector_free","text":"GrB_Vector_free(v)\n\nFree vector.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#SuiteSparseGraphBLAS.GrB_Descriptor_free","page":"Freeing objects","title":"SuiteSparseGraphBLAS.GrB_Descriptor_free","text":"GrB_Descriptor_free(desc)\n\nFree descriptor.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#Sequence-termination-1","page":"Sequence termination","title":"Sequence termination","text":"","category":"section"},{"location":"seq_ter/#","page":"Sequence termination","title":"Sequence termination","text":"GrB_wait\nGrB_error","category":"page"},{"location":"seq_ter/#SuiteSparseGraphBLAS.GrB_wait","page":"Sequence termination","title":"SuiteSparseGraphBLAS.GrB_wait","text":"GrB_wait()\n\nGrB_wait forces all pending operations to complete. Blocking mode is as if GrB_wait is called whenever a GraphBLAS method or operation returns to the user.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#SuiteSparseGraphBLAS.GrB_error","page":"Sequence termination","title":"SuiteSparseGraphBLAS.GrB_error","text":"GrB_error()\n\nEach GraphBLAS method and operation returns a GrB_Info error code. GrB_error returns additional information on the error.\n\nExamples\n\njulia> using SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_INVALID_VALUE::GrB_Info = 5\n\njulia> GrB_error()\nGraphBLAS error: GrB_INVALID_VALUE\nfunction: GrB_init (mode)\nGrB_init must not be called twice\n\n\n\n\n\n","category":"function"}]
}
