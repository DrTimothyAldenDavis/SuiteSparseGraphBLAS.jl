var documenterSearchIndex = {"docs":
[{"location":"#SuiteSparseGraphBLAS.jl","page":"Introduction","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl is a WIP package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis' SuiteSparse reference implementation of the GraphBLAS C specification.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"While the core library is mostly complete, and all GraphBLAS functionality is present, there are still quite a few features being worked on for v1.0:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ChainRules.jl integration for AD.\nComplete SparseArrays and ArrayInterface interfaces.\nImport and Export in all formats including bitmap and csr. Currently only dense and csc are supported.\nPrinting v2.\nUser-defined types and functions.\nAlternative syntax for GraphBLAS ops (currently must use BinaryOps.PLUS instead of +).\nComplex builtins.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once these are completed there will be a v1.0 release, with the goal being JuliaCon 2021.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Post 1.0 goals include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"LightGraphs integration.\nGeometricFlux or other graph machine learning framework integration.\nMore efficient import and export between Julia and GraphBLAS\nSupport for other GraphBLAS implementations in a follow-up GraphBLAS.jl","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"danger: Printing\nPrinting is done directly by GraphBLAS in this release. This means printed indices are 0-based, and the displayed type is the equivalent C type. The v1.0 release will alleviate this issue.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install using the Julia package manager in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add SuiteSparseGraphBLAS#master","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with Pkg","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"SuiteSparseGraphBLAS\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The SuiteSparse:GraphBLAS binary is installed automatically as SSGraphBLAS_jll.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS harnesses the well-understood duality between graphs and matrices.  Specifically a graph can be represented by its adjacency matrix, incidence matrix, or the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: BFS and Adjacency Matrix)","category":"page"},{"location":"#GraphBLAS-Concepts","page":"Introduction","title":"GraphBLAS Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.","category":"page"},{"location":"#GBArrays","page":"Introduction","title":"GBArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl provides GBVector and GBMatrix array types which are subtypes of SparseArrays.AbstractSparseVector and SparseArrays.AbstractSparseMatrix respectively. Both can be constructed with no arguments to use the maximum size.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> GBVector{Float64}()\n1152921504606846976x1 GraphBLAS double vector, sparse by col\n  no entries\n\n1152921504606846976x1152921504606846976 GraphBLAS int8_t matrix, hypersparse by col\n  no entries","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation. SuiteSparseGraphBLAS.jl sets the default to column major to ensure fast imports and exports.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A complete list of construction methods can be found in Construction, but the matrix and vector above can be constructed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\n7x7 GraphBLAS int64_t matrix, bitmap by col\n  12 entries\n\n    (3,0)   6\n    (0,1)   1\n    (3,2)   7\n    (5,2)   9\n    (6,2)   10\n    (0,3)   2\n    (6,3)   11\n    (1,4)   3\n    (6,4)   12\n    (2,5)   5\n    (4,5)   8\n    (1,6)   4\n\nv = GBVector([4], [10])\n4x1 GraphBLAS int64_t vector, bitmap by col\n  1 entry\n\n    (3,0)   10","category":"page"},{"location":"#GraphBLAS-Operations","page":"Introduction","title":"GraphBLAS Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A complete list of supported operations can be found in Operations. GraphBLAS operations are, where possible, wrapped in existing Julia functions. The equivalent Julia functions are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: assign vs subassign\nsubassign is equivalent to assign except that the mask in subassign has the dimensions of bf C(IJ) vs the dimensions of C for assign, and elements outside of the mask will never be modified by subassign.","category":"page"},{"location":"#Common-arguments","page":"Introduction","title":"Common arguments","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The operations above have a typical set of common arguments. These are:","category":"page"},{"location":"#op-UnaryOp,-BinaryOp,-Monoid,-or-Semiring:","page":"Introduction","title":"op - UnaryOp, BinaryOp, Monoid, or Semiring:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This is the key argument to most of these operations, which determines oplus, otimes, or f in the table above as well as the semiring used in mul. Most operations are restricted to one type of operator.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Keyword vs Positional\nFor some operations like mul and emul this is a keyword argument which defaults to the typical arithmetic operators. For others like map this is the first argument, since there is no sensible default choice.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"tip: Built-Ins\nThe built-in operators can be found in the submodules: UnaryOps, BinaryOps, Monoids, and Semirings.","category":"page"},{"location":"#desc-Descriptor:","page":"Introduction","title":"desc - Descriptor:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The descriptor argument allows the user to modify the operation in some fashion. The most common options are:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"desc.[input1 | input2] == [DEFAULT | TRANSPOSE] \nTransposes the inputs and can be found in Descriptors.[T0 | T1 | T0T1].    Typically you should use Julia's built-in transpose functionality.\ndesc.mask == [DEFAULT | STRUCTURE | COMPLEMENT | STRUCTURE + COMPLEMENT] \nIf STRUCTURE is set the operation will use the presence of a value rather than the value itself to determine whether the index is masked.    If COMPLEMENT is set the presence/truth value is complemented (ie. if no value is present or the value is false that index is masked).\ndesc.output == [DEFAULT | REPLACE]\nIf REPLACE is set the operation will replace all values in the output matrix after the accumulation step.    If an index is found in the output matrix, but not in the results of the operation it will be set to nothing. ","category":"page"},{"location":"#accum-BinaryOp:","page":"Introduction","title":"accum - BinaryOp:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The accum keyword argument provides a binary operation to accumulate results into the result array.  The accumulation step is performed before masking.","category":"page"},{"location":"#mask-GBArray:","page":"Introduction","title":"mask - GBArray:","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The mask keyword argument determines whether each index from the result of an operation appears in the output.  The mask may be structural, where the presence of a value indicates the mask is true, or valued where the value of the mask indicates its truth value.  The mask may also be complemented.","category":"page"},{"location":"#Order-of-Operations","page":"Introduction","title":"Order of Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A GraphBLAS operation occurs in the following order (steps are skipped when possible):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Calculate T = <operation>(args...)\nElementwise accumulate Z[i,j] = accum(C[i,j], T[i,j])\nOptionally masked assignment C[i,j] = mask[i,j] ? Z[i,j] : [nothing | C[i,j]]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"If REPLACE is set the option in step 3. is nothing, otherwise it is C[i,j].","category":"page"},{"location":"#GraphBLAS-Operators","page":"Introduction","title":"GraphBLAS Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS operators are one of the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"UnaryOps such as SIN, SQRT, ABS, ...\nBinaryOps such as GE, MAX, POW, FIRSTJ, ...\nMonoids such as PLUS_MONOID, LXOR_MONOID, ...\nSemirings such as PLUS_TIMES (the arithmetic semiring), MAX_PLUS (a tropical semiring), PLUS_PLUS, ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Built-in operators can be found in exported submodules:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> BinaryOps.\n\nANY       BSET       DIV        FIRSTJ1    ISGE       LDEXP      MIN        RDIV       SECONDJ\nATAN2     BSHIFT     EQ         FMOD       ISGT       LE         MINUS      REMAINDER  SECONDJ1\nBAND      BXNOR      FIRST      GE         ISLE       LOR        NE         RMINUS     TIMES\nBCLR      BXOR       FIRSTI     GT         ISLT       LT         PAIR       SECOND\nBGET      CMPLX      FIRSTI1    HYPOT      ISNE       LXOR       PLUS       SECONDI\nBOR       COPYSIGN   FIRSTJ     ISEQ       LAND       MAX        POW        SECONDI1","category":"page"},{"location":"#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"arrays/#GBArrays","page":"Arrays","title":"GBArrays","text":"","category":"section"},{"location":"arrays/#Construction","page":"Arrays","title":"Construction","text":"","category":"section"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"}]
}
